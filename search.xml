<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32参考文件</title>
      <link href="/2024/03/19/STM32%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6/"/>
      <url>/2024/03/19/STM32%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32参考文件"><a href="#STM32参考文件" class="headerlink" title="STM32参考文件"></a>STM32参考文件</h1><p>D:\blog\hexo\source\pdf\STM32F407 探索者开发指南V1.2.pdf</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Linux开发环境搭建及常用操作</title>
      <link href="/2024/03/08/00.Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/03/08/00.Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux开发环境搭建及常用操作"><a href="#Linux开发环境搭建及常用操作" class="headerlink" title="Linux开发环境搭建及常用操作"></a>Linux开发环境搭建及常用操作</h1><h2 id="Linux开发环境搭建"><a href="#Linux开发环境搭建" class="headerlink" title="Linux开发环境搭建"></a>Linux开发环境搭建</h2><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a><strong>方案一</strong></h4><ul><li>使用VM虚拟机+Ubuntu</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20231230184244150.png" alt="image-20231230184244150"></p><p><img src="/imgs/$%7Bfiilename%7D/83303.png" alt="img"></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a><strong>方案二</strong></h4><ul><li>WSL子系统(密码：123)<ul><li>基本配置</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/83300.png" alt="img"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221051875.png" alt="image-20240308221051875"></p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a><strong>方案三</strong></h4><ul><li>使用云服务器<ul><li>阿里、腾讯、华为…</li></ul></li></ul><p>如何登录：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221104200.png" alt="image-20231230184704887"></p><p>如何使用其它工具来使用云服务器：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221110734.png" alt="img"></p><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a><strong>编译环境</strong></h4><ul><li>VScode在Ubuntu中的安装（离线安装）</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221118196.png" alt="image-20231230184936805"></p><ul><li>输入安装命令进行安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxxx//xxxx指的是软件安装包名</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221129017.png" alt="image-20231230185043569"></p><h4 id="彻底卸载VM虚拟机"><a href="#彻底卸载VM虚拟机" class="headerlink" title="彻底卸载VM虚拟机"></a><strong>彻底卸载VM虚拟机</strong></h4><p><a href="https://blog.csdn.net/weixin_55118477/article/details/121078890">https://blog.csdn.net/weixin_55118477/article/details/121078890</a></p><h2 id="VM常用操作（熟练）"><a href="#VM常用操作（熟练）" class="headerlink" title="VM常用操作（熟练）"></a>VM常用操作（熟练）</h2><h4 id="虚拟机与电脑无法互相拖拽文件"><a href="#虚拟机与电脑无法互相拖拽文件" class="headerlink" title="虚拟机与电脑无法互相拖拽文件"></a><strong>虚拟机与电脑无法互相拖拽文件</strong></h4><p>​解决方法：</p><p>​更新VMtools :</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221144267.png" alt="image-20240103164558354"></p><h4 id="如何访问共享文件"><a href="#如何访问共享文件" class="headerlink" title="如何访问共享文件"></a><strong>如何访问共享文件</strong></h4><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221238822.png" alt="image-20240308221238822"></p><p>图形界面：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221245056.png" alt="image-20240103164623486"></p><h4 id="如何快速打开终端"><a href="#如何快速打开终端" class="headerlink" title="如何快速打开终端"></a><strong>如何快速打开终端</strong></h4><ul><li>Cntl  + Alt  + T</li></ul><h4 id="如何更新软件原（软件菜单）列表："><a href="#如何更新软件原（软件菜单）列表：" class="headerlink" title="如何更新软件原（软件菜单）列表："></a><strong>如何更新软件原（软件菜单）列表：</strong></h4><p><strong>使用图形界面进行更新：</strong></p><p>默认系统是使用的国外的服务器去安装软件，因此我们直接装会受到网络的限制（非常慢）</p><ul><li>把软件下载的服务器设置为国内的服务器</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221255148.png" alt="image-20240103164638863"></p><ul><li><p>更新服务器的软件菜单列表</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240308221300175.png" alt="image-20240103164658864"></p></li><li><ul><li><p>更新列表后可以进行安装软件（在线安装）</p></li><li><pre><code>sudo  apt install  xxxx   // xxxx 指的是具体的软件的名称<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - </span><br><span class="line"></span><br><span class="line">#### **通过修改文件进行更改软件源列表（**通用****）：</span><br><span class="line"></span><br><span class="line">- - 确定当前需要修改的系统的版本</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>$ lsb_release  -a<br>No LSB modules are available.<br>Distributor ID: Ubuntu<br>Description:    Ubuntu 20.04 LTS<br>Release:        20.04<br>Codename:       focal</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- - 从网络中搜索得到服务器的软件源的列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#添加阿里源<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- - 创建一个新的文本文件并把名字修改为 sources.list</span><br><span class="line">  - 直接编辑该文件</span><br><span class="line"></span><br><span class="line">![image-20240103164915504](/imgs/$%7Bfiilename%7D/image-20240308221313614.png)</span><br><span class="line"></span><br><span class="line">- - 把该文件复制到系统中的默认路径中进行覆盖原有的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cd &#x2F;mnt&#x2F;d&#x2F;GZ2301&#x2F;     &#x2F;&#x2F; 切换工作路径到共享文件中D盘中 GZ2301 文件夹中<br>sudo cp  sources.list  &#x2F;etc&#x2F;apt&#x2F;  &#x2F;&#x2F; 把文件sources.list 复制 到 &#x2F;etc&#x2F;apt&#x2F; 进行覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- - 更新软件源列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sudo apt update</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **安装与卸 载**</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>gec@ubuntu:~$ sudo apt install xxx</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>gec@ubuntu:<del>$ sudo apt remove xxx<br>gec@ubuntu:</del>$ sudo apt remove –purge xxx #将配置文件也一并删除</p><h1 id="修复APT管理器"><a href="#修复APT管理器" class="headerlink" title="修复APT管理器"></a>修复APT管理器</h1><p>gec@ubuntu:~$ sudo apt install -f</p><h1 id="自动卸载一些已经无用的软件或服务"><a href="#自动卸载一些已经无用的软件或服务" class="headerlink" title="自动卸载一些已经无用的软件或服务"></a>自动卸载一些已经无用的软件或服务</h1><p>gec@ubuntu:~$ sudo apt autoremove</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### **如何设置虚拟机的语言**</span><br><span class="line"></span><br><span class="line">安装语言支持包：</span><br><span class="line"></span><br><span class="line">![image-20240103165010588](/imgs/$%7Bfiilename%7D/image-20240308221322644.png)</span><br><span class="line"></span><br><span class="line">![image-20240103165014621](/imgs/$%7Bfiilename%7D/image-20240308221326019.png)</span><br><span class="line"></span><br><span class="line">##### **如何安装中文输入法（搜狗输入）**</span><br><span class="line"></span><br><span class="line">- - 配置中文环境</span><br><span class="line">  - 下载搜狗输入法安装包</span><br><span class="line">  - 安装 sudo dpkg -i xxx文件.deb</span><br><span class="line"></span><br><span class="line">![image-20240103165036404](/imgs/$%7Bfiilename%7D/image-20240308221331000.png)</span><br><span class="line"></span><br><span class="line">- - 出现如上问题是由于已经存在了某一个工具，与输入法有冲突并DPKG工具无法解决该工具问题</span><br><span class="line"></span><br><span class="line">  - - 可以直接使用命令把该工具卸载后再安装 sudo apt remove  fcitx-ui-qimpanel</span><br><span class="line"></span><br><span class="line">![image-20240103165055060](/imgs/$%7Bfiilename%7D/image-20240308221335834.png)</span><br><span class="line"></span><br><span class="line">- - 安装成功后 ，注销并重新登录 （重启虚拟机）</span><br><span class="line">  - 配置输入法</span><br><span class="line"></span><br><span class="line">![image-20240103165103689](/imgs/$%7Bfiilename%7D/image-20240308221339012.png)</span><br><span class="line"></span><br><span class="line">- - 按下 Cntl  + 空格调出输入法</span><br><span class="line"></span><br><span class="line">![image-20240103165114394](/imgs/$%7Bfiilename%7D/image-20240308221348197.png)</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果安装过程中提示缺少相关依赖，则执行如下命令解决：<br>sudo apt -f install</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **虚拟机的网络如何配置**</span><br><span class="line"></span><br><span class="line">- 检查VM网络是否正确配置</span><br><span class="line"></span><br><span class="line">![image-20240103165147554](/imgs/$%7Bfiilename%7D/image-20240308221356994.png)</span><br><span class="line"></span><br><span class="line">- 检查虚拟机的网络是否正确配置</span><br><span class="line"></span><br><span class="line">![image-20240103165157259](/imgs/$%7Bfiilename%7D/image-20240308221407659.png)</span><br><span class="line"></span><br><span class="line">##### **如何设置电脑的IP地址：**</span><br><span class="line"></span><br><span class="line">![image-20240103165206403](/imgs/$%7Bfiilename%7D/image-20240308221414640.png)</span><br><span class="line"></span><br><span class="line">如果设置过程中出现不允许设置等提示可以尝试使用命令进行设置：</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="设置-IP-网关-掩码"><a href="#设置-IP-网关-掩码" class="headerlink" title="设置 IP+网关+掩码"></a>设置 IP+网关+掩码</h2><p>netsh interface ipv4 set address “以太网2” static 192.168.1.99 255.255.255.0 192.168.1.254</p><h2 id="设置DNS"><a href="#设置DNS" class="headerlink" title="设置DNS"></a>设置DNS</h2><p>netsh interface ipv4 set dnsservers “以太网2” static 202.96.128.86 primary</p><pre><code>#### **可能遇到的问题**- **VMtools 安装：**  如果发现如下情况，重新安装的按钮为灰色则需要创建一个新的”光驱“![image-20231231145422050](/imgs/$%7Bfiilename%7D/image-20240308221439944.png)![image-20231231145439024](/imgs/$%7Bfiilename%7D/image-20231231145439024.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/03/VScode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2024/03/03/VScode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>VScode常用快捷键</p><p>选中代码后 Alt+方向键可以移动代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>（二十）头文件</title>
      <link href="/2024/02/27/20.%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2024/02/27/20.%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h4 id="头文件的作用"><a href="#头文件的作用" class="headerlink" title="头文件的作用"></a><strong>头文件的作用</strong></h4><p>通常，一个常规的C语言程序会包含多个源码文件（**.c）<strong>，当某些公共资源需要在各个源码文件中使用时，为了避免多次编写相同的代码，一般的做法是将这些大家都需要用到的</strong>公共资源放入头文件**（.h）当中，然后在各个源码文件中直接包含即可。    <img src="/imgs/$%7Bfiilename%7D/image-20240306013817462.png" alt="0"></p><h4 id="头文件的内容"><a href="#头文件的内容" class="headerlink" title="头文件的内容"></a><strong>头文件的内容</strong></h4><ul><li>头文件中所存放的内容，就是各个源码文件的彼此可见的公共资源，包括：</li></ul><ol><li>全局变量的声明（也可以定义【谨慎赋值】，但是不建议）。</li><li>普通函数的声明(告诉编译器函数的参数以及返回类型【接口的模型】)。</li><li>静态函数（被static修饰的函数可见范围为本文件）的定义。</li><li>宏定义。</li><li>结构体、联合体的声明。</li><li>枚举常量列表的声明。</li><li>其他头文件</li></ol><p>基础语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef    __头文件名_H__   // 条件编译， 判断宏  __头文件名_H__ 是否没有定义</span><br><span class="line">#define    __头文件名_H__   // 定义宏  __头文件名_H__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif   //条件编译语句的结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>头文件的格式  #ifndef  #define 的作用是为了防止头文件被多次重复包含而造成重复定义的问题</p></li><li><p>编译器在编译程序的时候会主动去寻找头文件而他默认寻找的路基有以下几个：    <img src="/imgs/$%7Bfiilename%7D/image-20240306013829119.png" alt="0"></p></li></ul><p>如果希望编译器在我们指定的路径下去寻找头文件则需要在编译命令后面指定头文件寻找的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -I./ -v  //  -I  则是告诉编译器 头文件寻找的路径  ./ 为当前路路径</span><br><span class="line">     //  -v 显示编译器的版本信息以及一些编译选项 【一般不需要添加】</span><br></pre></td></tr></table></figure><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240306013834752.png" alt="0"></p><p>头文件的基础格式实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#ifndef     __MY_TYPES_H_  // 判断是否没有定义  __MY_TYPES_H_ ，用于防止头文件被多次包含</span><br><span class="line">#define     __MY_TYPES_H_ // 配合上一句一起使用</span><br><span class="line"></span><br><span class="line">// 宏定义</span><br><span class="line">#define     PI 3.14 </span><br><span class="line"></span><br><span class="line">// 声明外部变量 a  (告诉编译器 a 是整形的， 而且它是在其他文件中定义了你不需要担心)</span><br><span class="line">extern int a ; </span><br><span class="line"></span><br><span class="line">// 如果想在头文件中定义全局变量那么注意不要对她进行赋值，</span><br><span class="line">// 如果赋值了那么在项目编译阶段很有可能会出现重复定义的问题</span><br><span class="line">int b ;</span><br><span class="line">// int c = 100 ; // [报错] multiple definition of `c&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 枚举常量列表声明</span><br><span class="line">typedef enum Stat &#123; open , running , stop , sleep &#125;  stat ;</span><br><span class="line"></span><br><span class="line">// 联合体类型声明</span><br><span class="line">typedef union info</span><br><span class="line">&#123;</span><br><span class="line">    int Num ;</span><br><span class="line">    char Type;</span><br><span class="line">    float Abc; </span><br><span class="line">&#125;Info ;</span><br><span class="line"></span><br><span class="line">// 结构体的声明</span><br><span class="line">struct MyTypes</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32];</span><br><span class="line">    stat Test ;</span><br><span class="line">    Info TestInfo ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 静态函数的定义</span><br><span class="line">/*</span><br><span class="line"> * 函数名字：FuncA</span><br><span class="line"> * 函数功能：xxxxxx描述该函数的作用</span><br><span class="line"> * 函数参数： </span><br><span class="line"> *  @a xxx该参数的作用 </span><br><span class="line"> *  @b xxx该参数的作用  </span><br><span class="line"> *  @d xxx该参数的作用</span><br><span class="line"> * 函数的返回值： </span><br><span class="line"> *  成功：</span><br><span class="line"> *  失败：</span><br><span class="line"> * 作者：</span><br><span class="line"> * 修改时期：</span><br><span class="line"> * 修改内容：</span><br><span class="line">*/</span><br><span class="line">static void FuncA( int a , char b , double d  )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a:%d _%s_%s_ \n&quot; , a , __FUNCTION__ , __FILE__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif  // 结束整个头文件的判断语句</span><br></pre></td></tr></table></figure><h4 id="如何妥善把项目分成多个文件"><a href="#如何妥善把项目分成多个文件" class="headerlink" title="如何妥善把项目分成多个文件"></a><strong>如何妥善把项目分成多个文件</strong></h4><p>  <img src="/imgs/$%7Bfiilename%7D/image-20240306013846986.png" alt="0"></p><p>对应以上工程我们如何编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gcc src/mian.c  src/Input.c src/Output.c -o ./bin/main -I./inc -lc -lgcc </span><br><span class="line"> </span><br><span class="line">gcc  src/*.c  -o ./bin/main -I./inc  // src/*.c 指的是编译 src内的所有 .c 文件</span><br><span class="line"> </span><br><span class="line"> gcc               // 需要使用的编译器</span><br><span class="line"> src/mian.c        // 需要编译的源文件 1 </span><br><span class="line"> src/Input.c       // 需要编译的源文件 2 </span><br><span class="line"> src/Output.c      // 需要编译的源文件 3 </span><br><span class="line"> -o                // 指定在特定的路径下生成指定文件名 </span><br><span class="line"> ./bin/main        // 生成目标文件的 路径 + 文件名</span><br><span class="line"> -I./inc           // -I  include  指明头文件的路径</span><br><span class="line"> -L./lib           // -L  指明链接库的文件路径</span><br><span class="line"> -lc               // -l 指定需要链接的库文件的名字 为 c 库  全称【libx.so】</span><br><span class="line"> -lgcc             // -l 指定需要链接的库文件的名字 为 gcc 库  全称【libgcc.so】</span><br></pre></td></tr></table></figure><p>暂时也可以使用简单的 “shell 脚本文件” 来帮助我们编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc  src/*.c  -o ./bin/main -I./inc  // 编译命令</span><br><span class="line">./bin/main                // 执行程序的命令gcc  src/*.c  -o ./bin/main -I./inc  // 编译命令 ./bin/main                // 执行程序的命令</span><br></pre></td></tr></table></figure><p>其他的操作：</p><h4 id="C语言显示字体颜色等操作："><a href="#C语言显示字体颜色等操作：" class="headerlink" title="C语言显示字体颜色等操作："></a>C语言显示字体颜色等操作：</h4><p><a href="https://blog.csdn.net/qq_40399012/article/details/84195092">https://blog.csdn.net/qq_40399012/article/details/84195092</a></p><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240306013905092.png" alt="0">    <img src="/imgs/$%7Bfiilename%7D/image-20240306013929909.png" alt="0"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\33[42;31;4m \33[10;30H %s\033[0m\n&quot;, Name[i]);</span><br><span class="line"></span><br><span class="line">\33[   开始设置</span><br><span class="line">42;    背景色</span><br><span class="line">31;    字体颜色</span><br><span class="line">4m     下划线</span><br><span class="line">\33[10;30H   设置光标的位置 y=10  x=30</span><br><span class="line">%s     需要输出的数据</span><br><span class="line">\033[0m  设置结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="随机数产生"><a href="#随机数产生" class="headerlink" title="随机数产生"></a>随机数产生</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // time 函数是用于获取当前的系统时间（秒） ， 根据这个秒作为随机种子</span><br><span class="line">    srand((int)time(0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 1 + (int) (100.0 * rand() / (RAND_MAX + 1.0));</span><br><span class="line">        printf(&quot;rand:%d\n&quot; , j );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十九）条件编译</title>
      <link href="/2024/02/27/19.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2024/02/27/19.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><h4 id="无值宏定义"><a href="#无值宏定义" class="headerlink" title="无值宏定义"></a><strong>无值宏定义</strong></h4><p>概念： 该宏的定义语句中不需要给宏指定指定的值，因此它在代码中并没有实际的意义，一般用于条件编译的判断语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define BIG_ENDIAN</span><br><span class="line">#define __cplusplus</span><br></pre></td></tr></table></figure><h4 id="条件编译-1"><a href="#条件编译-1" class="headerlink" title="条件编译"></a><strong>条件编译</strong></h4><ul><li>概念：有条件的编译，通过控制某些宏的值（或某个宏是否有定义），来决定编译哪段代码。</li><li>基本语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if A  // 判断 宏 A 它的值是否为真</span><br><span class="line">    ... // 如果 MACRO 为真，那么该段代码将被编译，否则被丢弃</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// C 中的条件判断语句</span><br><span class="line">if( 布尔表达式 )</span><br><span class="line">&#123;</span><br><span class="line">    // 根据条件是否需要执行本代码块</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形式：</li><li>形式1：判断表达式 MACRO 是否为真，据此决定其所包含的代码段是否要编译</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG 100 </span><br><span class="line"></span><br><span class="line">// 根据宏 DEBUG 的值来决定是否编译 第 14行代码  非零 则真 </span><br><span class="line">#if  DEBUG </span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line">#endif</span><br><span class="line">#define     DEBUG       100  // 根据宏 DEBUG 的值来决定是否编译 第 14行代码  非零 则真  #if  DEBUG     printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ ); #endif</span><br></pre></td></tr></table></figure><ul><li>形式2：判断某一个宏是否被<strong>定义（无宏值定义）</strong>了或是否没有被定义，据此决定其所包含的代码段是否要编译</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断宏 DEBUG 是否有定义， 如果有则以下代码是生效的，否则不生效</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 判断宏 DEBUG 是否没有定义， 如果没有则以下代码是生效的，否则不生效</span><br><span class="line">#ifndef DEBUG</span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li><p>注意：#if形式条件编译需要有值宏</p></li><li><p>如果宏没有定义而且条件编译的判断语句是使用 形式1 （判断值） ，则表达式默认不成立（默认为假）。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define A 0</span><br><span class="line">#define B 1</span><br><span class="line">#define C 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if A</span><br><span class="line">    ... // 如果 MACRO 为真，那么该段代码将被编译，否则被丢弃</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 二路分支</span><br><span class="line">#if A</span><br><span class="line">    ... </span><br><span class="line">#elif B</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 多路分支</span><br><span class="line">#if A</span><br><span class="line">    ... </span><br><span class="line">#elif B</span><br><span class="line">    ...</span><br><span class="line">#elif C</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#if DEBUG  // 判断宏  DEBUG 是否为真， 如果是则编译 以下代码块</span><br><span class="line"></span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line"></span><br><span class="line">#elif TEST // 如果宏 DEBUG 为假， 则判断 宏 TEST 是否为真 ，如果为真则生效以下代码块</span><br><span class="line"></span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line"></span><br><span class="line">#else // 如果   DEBUG 为假 且 宏 TEST 是为假 ，则生效以下代码块</span><br><span class="line"></span><br><span class="line">    printf(&quot;__%d__%s__%s__\n&quot; , __LINE__ , __FUNCTION__ , __FILE__ );</span><br><span class="line"></span><br><span class="line">#endif  // 条件判断的结束</span><br></pre></td></tr></table></figure><ul><li><p>总结：</p><ul><li><p>#ifdef  或 #ifndef 此种形式，判定的是宏是否已被定义，这不要求宏有值（有值无值都可以）。</p></li><li><p>#if 、#elif 这些形式，判定的是宏的值是否为真，这要求宏必须有值。</p></li><li><p>只要出现了 #if  #ifdef  #ifndef 就<strong>必须在最后加上 #endif 表示结束判断</strong></p></li></ul></li></ul><h4 id="条件编译的使用场景"><a href="#条件编译的使用场景" class="headerlink" title="条件编译的使用场景"></a><strong>条件编译的使用场景</strong></h4><p>控制调试语句：在程序中，用条件编译将调试语句包裹起来，通过gcc编译选项随意控制调试代码的启停状态。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example -DDEBUG  // 通过命令行编译的时候定义宏 DEBUG 如果没有赋值默认为真</span><br><span class="line">gcc example.c -o example -DDEBUG=0 -DTEST=1 // 在定义宏 DEBUG的时候赋值为 0   定义 宏TEST 的时候赋值为 1 </span><br></pre></td></tr></table></figure><p>以上语句中，-D意味着 Define，DEBUG 是程序中用来控制调试语句的一个宏，如此一来就可以在完全不需要修改源代码的情况下，通过外部编译指令选项非常方便地控制调试信息的启停。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十八）宏</title>
      <link href="/2024/02/27/18.%E5%AE%8F/"/>
      <url>/2024/02/27/18.%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p><img src="/imgs/$%7Bfiilename%7D/image-20240305161449816.png" alt="image-20240305161449816"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240227135349107.png" alt="image-20240227135349107"></p><h4 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h4><p>​GCC 在第一个阶段会调用预处理器 cpp 来对 C 源程序进行预处理，所谓的<strong>预处理</strong>就是<strong>解释源程序当中的所有的预处理指令</strong>，那些诸如#include、#define、#if 等以井号’#’开头的语句就是预处理指令，预处理指令实际上并不是 C 语言本身的组成部分，而是为了更好地组织程序所使用的一些<strong>“预先处理的”工作</strong>，这些工作用一种叫做与处理指令的语句来描述，然后用预处理器来解释，这些工作包括我们熟悉的诸如<strong>文件包含、宏定义、条件编译</strong>等等。</p><blockquote><p>gcc 02\ 联合体的实际例子.c -o Even.i -E</p><p>加上一个编译选项 -E 就可以使得 GCC 在进行完第一阶段的预处理之后停下来，生成一个默认后缀名为.i 的文本文件。</p></blockquote><h4 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h4><p>经过预处理之后生成的.i 文件依然是一个文本文件，不能被处理器直接解释，我们需要进一步的翻译。接下来的编译阶段是四个阶段中<strong>最为复杂的阶段</strong>，它包括<strong>词法</strong>和<strong>语法</strong>的分析（检查代码是否出现语法错误），最终生成对应硬件平台的汇编语言（不同的处理器有不同的汇编格式），具体生成什么平台，的汇编文件取决于所采用的编译器，如果用的是 GCC，那么将会生成 x86 格式的汇编文件，如果用的是针对 ARM 平台的交叉编译器，那么将会生成 ARM 格式的汇编文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 02\ 联合体的实际例子.c  -o Even.s -S</span><br></pre></td></tr></table></figure><p>加上一个编译选项 -S 就可以使得 gcc 在进行完第一和第二阶段之后停下来，生成一个默认后缀名为.s 的文本文件。</p><h4 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h4><p>​接下来的步骤相对而言比较简单，编译器 gcc 将会调用汇编器 as 将汇编源程序翻译成为可重定位文件(二进制的可‘执行文件’)。汇编指令跟处理器直接运行的二进制指令流之间基本是一一对应的关系，该阶段只需要将.s 文件里面的汇编翻译成指令即可。</p><p>​只要在编译的时候加上一个编译选项-c，则会生成一个扩展名为.o 的文件，这个文件是一个 ELF 格式的可重定位(relocatable)文件。</p><p>​所谓的可重定位，指的是该文件虽然已经包含可以让处理器直接运行的指令流，但是程序中的所有的全局符号（全局变量或函数的入口地址等..）尚未定位（未确定其地址），所谓的全局符号，就是指函数和全局变量，函数和全局变量默认情况下是可以被外部文件引用的，由于定义和调用可以出现在不同的文件当中，因此他们在编译的过程中需要确定其入口地址，比如 a.c 文件里面定义了一个函数 func( )，b.c 文件里面调用了该函数，那么在完成第三阶段汇编之后，b.o 文件里面的函数 func( )的地址将是 0，显然这是不能运行的，必须要找到 a.c 文件里面函数 func( )的确切的入口地址，然后将 b.c 中的“全局符号”func重新定位为这个地址，程序才能正确运行。因此，接下来需要进行第四个阶段：链接。</p><h4 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h4><p>如前面所述，经过汇编之后的可重定位文件不能直接运行，因为还有两个很重要的工作没完成，首先是重定位（确定全局符号的确切地址），其次是合并相同权限的段（每一个可冲定位的文件中都有自己的数据段、代码段等…）。关于重定位的问题，上面已经给出了简单的描述。更一般的地，我们编译一个程序通常都需要链接系统的标准 C 库、gcc 内置库等基本库文件。因为 Linux 下任何一个程序编译都需要用到这些基本库的全局符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vincent@ubuntu:~$ gcc hello.o -o hello -lc -lgcc</span><br></pre></td></tr></table></figure><p>标准 C 库和 gcc 内置库是如此的基本，因此-lc 和-lgcc 是默认的，可以省略。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a><strong>预处理</strong></h4><p>在C语言程序源码中，凡是以井号（#）开头的语句被称为预处理语句，这些语句严格意义上并不属于C语言语法的范畴，它们在编译的阶段统一由所谓预处理器（cc1）来处理。所谓预处理，顾名思义，指的是真正的C程序编译之前预先进行的一些处理步骤，这些预处理指令包括：</p><ol><li>头文件：#include</li><li>定义宏：#define</li><li>取消宏：#undef</li><li>条件编译：#if、#ifdef、#ifndef、#else、#elif、#endif</li><li>显示错误：#error</li><li>修改当前文件名和行号：#line</li><li>向编译器传送特定指令：#progma</li></ol><ul><li><p>基本语法</p><ul><li><p>一个逻辑行只能出现一条预处理指令，多个物理行需要用反斜杠 \  连接成一个逻辑行</p></li><li><p>预处理是整个编译全过程的第一步：预处理 - 编译 - 汇编 - 链接</p></li><li><p>可以通过如下编译选项来指定来限定编译器只进行预处理操作：</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example.i -E</span><br></pre></td></tr></table></figure><h4 id="宏的概念"><a href="#宏的概念" class="headerlink" title="宏的概念"></a><strong>宏的概念</strong></h4><p>宏（macro）实际上就是一段特定的字串，在源码中用以替换为指定的表达式。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define 宏   对应的值（表达式）</span><br><span class="line">#define PI   3.14</span><br></pre></td></tr></table></figure><p>此处，PI 就是宏（宏一般习惯用全大写字母表达，以区分于变量和函数，但这并不是语法规定，只是一种习惯），是一段特定的字串，这个字串在源码中出现时，将被替换为3.14。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define     PI    3.141592 </span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    PI</span><br><span class="line"></span><br><span class="line">    PI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;PI:%f&quot; , PI ) PI; PI</span><br><span class="line"></span><br><span class="line">    PI</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>宏的作用：</p><ul><li><p>使得程序更具可读性：字串单词一般比纯数字更容易让人理解其含义。</p></li><li><p>使得程序修改更易行：修改宏定义，即修改了所有该宏替换的表达式。</p></li><li><p>提高程序的运行效率：程序的执行不再需要函数切换开销（宏函数），而是就地展开。</p></li></ul></li></ul><p>实际例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define ARR_LEN 10</span><br><span class="line">#define BUF_LEN 32</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr [ ARR_LEN ] = &#123;0&#125; ;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; ARR_LEN ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char * ptr = malloc(BUF_LEN);</span><br><span class="line"></span><br><span class="line">    memcpy(ptr , msg , BUF_LEN );</span><br><span class="line">    bzero(ptr , BUF_LEN );</span><br><span class="line">    strcpy(ptr , msg , BUF_LEN );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无参宏"><a href="#无参宏" class="headerlink" title="无参宏"></a><strong>无参宏</strong></h4><p>无参宏意味着使用宏的时候，无需指定任何参数，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define PI          3.14</span><br><span class="line">#define SCREEN_SIZE 800*480*4 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 在代码中，可以随时使用以上无参宏，来替代其所代表的表达式：</span><br><span class="line">    printf(&quot;圆周率: %f\n&quot;, PI); </span><br><span class="line">    mmap(NULL, SCREEN_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，上述代码中，除了有自定义的宏，还有系统预定义的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 自定义宏:</span><br><span class="line">#define PI          3.14</span><br><span class="line">#define SCREEN_SIZE 800*480*4 </span><br><span class="line"></span><br><span class="line">// 系统预定义宏</span><br><span class="line">#define NULL ((void *)0)</span><br><span class="line">#define PROT_READ    0x1    /* Page can be read.  */</span><br><span class="line">#define PROT_WRITE    0x2    /* Page can be written.  */</span><br><span class="line">#define MAP_SHARED    0x01    /* Share changes.  */</span><br></pre></td></tr></table></figure><p>宏的最基本特征是进行直接文本替换。</p><h4 id="带参宏"><a href="#带参宏" class="headerlink" title="带参宏"></a><strong>带参宏</strong></h4><p>带参宏意味着宏定义可以携带“参数”，从形式上看跟函数很像，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a, b)   a&gt;b ? a : b</span><br><span class="line">#define MIN(a, b)   a&lt;b ? a : b</span><br></pre></td></tr></table></figure><p>以上的MAX(a,b) 和 MIN(a,b) 都是带参宏，不管是否带参，宏都遵循最初的规则，即宏是一段待替换的文本，例如在以下代码中，宏在预处理阶段都将被替换掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x = 100, y = 200;</span><br><span class="line">    printf(&quot;最大值:%d\n&quot;, MAX(x, y));</span><br><span class="line">    printf(&quot;最小值:%d\n&quot;, MIN(x, y));</span><br><span class="line">    // 以上代码等价于:</span><br><span class="line">    // printf(&quot;最大值:%d\n&quot;, x&gt;y ? x : y);</span><br><span class="line">    // printf(&quot;最小值:%d\n&quot;, x&lt;y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带参宏的特点：<ol><li>直接文本替换，不做任何语法判断，更不做任何中间运算。</li><li>宏在编译的第一个阶段就被替换掉，运行中不存在宏。</li><li>宏将在所有出现它的地方展开，这一方面浪费了内存空间，另一方面又节约了切换时间。</li></ol></li></ul><h4 id="带参宏的副作用"><a href="#带参宏的副作用" class="headerlink" title="带参宏的副作用"></a><strong>带参宏的副作用</strong></h4><p>​由于<strong>宏仅仅做文本替换</strong>，中间不涉及任何语法检查、类型匹配、数值运算，因此用起来相对函数要麻烦很多。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a, b) a&gt;b ? a : b</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x = 100, y = 200;</span><br><span class="line">    printf(&quot;最大值:%d\n&quot;, MAX(x, y==200?888:999));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观上看，无论 y 的取值是多少，表达式 y&#x3D;&#x3D;200?888:999 的值一定比 x 要大，但由于宏定义仅仅是文本替换，<strong>中间不涉及任何运算</strong>，因此等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;最大值:%d\n&quot;, x&gt;y==200?888:999 ? x : y==200?888:999);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，带参宏的参数不能像函数参数那样视为一个整体，整个宏定义也不能视为一个单一的数据，事实上，不管是宏参数还是宏本身，都应被视为一个字串，或者一个表达式，或者一段文本，因此最基本的原则是：</p><ul><li><strong>将宏定义中所有能用括号括起来的部分，都括起来(单独强调每一个变量的整体性避免替换后出现优先级的问题)，比如：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a, b) ((a)&gt;(b) ? (a) : (b))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十七）枚举类型</title>
      <link href="/2024/02/27/17.%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/02/27/17.%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h4><p>枚举类型的本质是提供一种范围受限的整型，比如用0-6表示七种颜色，用0-3表示四种状态等，但枚举在C语言中并未实现其本来应有的效果，直到C++环境下枚举才拥有原本该有的属性。</p><ul><li><p>枚举常量列表</p><ul><li><p>enum是关键字</p></li><li><p>spectrum是枚举常量列表标签，可以省略。省略的情况下无法定义枚举变量</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum spectrum&#123;red, orange, yellow, green, blue, cyan, purple&#125;;</span><br><span class="line">enum         &#123;reset, running, sleep, stop&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>语法要点：</p><ul><li><p>枚举常量实质上就是整型，首个枚举常量默认为0。</p></li><li><p>枚举常量在定义时可以赋值，若不赋值，则取其前面的枚举常量的值加1。</p></li><li><p>C语言中，枚举等价于整型，支持整型数据的一切操作。</p></li><li><p>枚举数据最重要的作用，是使用有意义的单词，来替代无意义的数字，提高程序的可读性。</p></li></ul></li></ul><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 声明枚举常量列表</span><br><span class="line">enum Status &#123;reset, running , sleep, stop&#125;;</span><br><span class="line"></span><br><span class="line">enum Status GetStat()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    enum Status stat ;</span><br><span class="line">    scanf(&quot;%d&quot; , &amp;stat);</span><br><span class="line">    </span><br><span class="line">    return stat ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        // 假设这个函数是用于获取某一个硬件设备的工作状态的...</span><br><span class="line">        int ret = GetStat() ;</span><br><span class="line">        </span><br><span class="line">        switch (ret)</span><br><span class="line">        &#123;</span><br><span class="line">            case reset:</span><br><span class="line">                printf(&quot;当前正处于复位状态...\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            case running:</span><br><span class="line">                printf(&quot;当前正处于运行状态...\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            case sleep:</span><br><span class="line">                printf(&quot;当前正处于睡眠状态...\n&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case stop:</span><br><span class="line">                printf(&quot;当前正处于停止状态...\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        </span><br><span class="line">            default:</span><br><span class="line">                printf(&quot;当前正处于未知状态...\n&quot;);</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十六）联合体</title>
      <link href="/2024/02/27/16.%E8%81%94%E5%90%88%E4%BD%93/"/>
      <url>/2024/02/27/16.%E8%81%94%E5%90%88%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h2><h4 id="联合体基本概念"><a href="#联合体基本概念" class="headerlink" title="联合体基本概念"></a><strong>联合体基本概念</strong></h4><p>​联合体的外在形式跟结构体非常类似，但它们有一个本质的区别：结构体中的各个成员是各自独立的，而联合体中的各个成员却共用同一块内存，因此联合体也称为共用体。</p><p>联合体各成员的堆叠效果</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240305161620032.png" alt="image-20240305161620032"></p><p>联合体内部成员的这种特殊的“堆叠”效果，使得联合体有如下基本特征：</p><ul><li>整个联合体变量的尺寸，取决于联合体中尺寸最大的成员。</li><li>给联合体的某个成员赋值，会覆盖其他的成员，使它们失效（可能会无意义）。</li><li>联合体各成员之间形成一种“互斥”的逻辑，在某个时刻只有一个成员有效。</li></ul><p>联合体的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union 联合体标签</span><br><span class="line">&#123;</span><br><span class="line">    成员1;</span><br><span class="line">    成员2;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>语法：</p></li><li><ul><li>联合体标签，用来区分各个不同的联合体。</li><li>成员，是包含在联合体内部的数据，可以是任意的数据类型。</li></ul><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240227135037489.png" alt="image-20240227135037489">![</p></li></ul><h4 id="联合体操作"><a href="#联合体操作" class="headerlink" title="联合体操作"></a><strong>联合体操作</strong></h4><p>联合体的操作跟结构体形式上别无二致，但由于联合体特殊的存储特性，不管怎么初始化和赋值，最终都有且仅有一个成员是有效的。</p><ul><li>初始化：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 普通初始化：第一个成员有效（即只有100是有效的，其余成员会被覆盖）</span><br><span class="line">union attr at = &#123;100, &#x27;k&#x27;, 3.14&#125;;</span><br><span class="line"></span><br><span class="line">// 指定成员初始化：最后一个成员有效（即只有3.14是有效的，其余成员会被覆盖）</span><br><span class="line">union attr at = &#123;</span><br><span class="line">                .x  = 100,</span><br><span class="line">                .y = &#x27;k&#x27;,</span><br><span class="line">                .z = 3.14,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>成员引用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at.x = 100;</span><br><span class="line">at.y = &#x27;k&#x27;;</span><br><span class="line">at.z = 3.14; // 只有最后一个赋值的成员有效</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, at.x);</span><br><span class="line">printf(&quot;%c\n&quot;, at.y);</span><br><span class="line">printf(&quot;%lf\n&quot;, at.z);</span><br></pre></td></tr></table></figure><ul><li>联合体指针：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union attr *p = &amp;at;</span><br><span class="line">p-&gt;x = 100;</span><br><span class="line">p-&gt;y = &#x27;k&#x27;;</span><br><span class="line">p-&gt;z = 3.14;  // 只有最后一个赋值的成员有效</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, p-&gt;x);</span><br><span class="line">printf(&quot;%c\n&quot;, p-&gt;y);</span><br><span class="line">printf(&quot;%lf\n&quot;, p-&gt;z);</span><br></pre></td></tr></table></figure><h4 id="联合体的使用"><a href="#联合体的使用" class="headerlink" title="联合体的使用"></a><strong>联合体的使用</strong></h4><p>​联合体一般很少单独使用，而经常以结构体的成员形式存在，用来表达某种互斥的属性。</p><p>实际例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32] ;</span><br><span class="line">    int Age ;</span><br><span class="line">    char Type ; // S 学生  T 老师  A 阿姨</span><br><span class="line"></span><br><span class="line">    // 在结构体中嵌套的联合体，用于描述不同类型的人物的属性</span><br><span class="line">    union </span><br><span class="line">    &#123;</span><br><span class="line">        float PerPoint ; // 如果是学生则用于描述学生的绩点 </span><br><span class="line">        char Level ; //  如果是一个老师则用于描述该老师 职称 A B C S </span><br><span class="line">        int Jitter ; // 如果是饭堂阿姨则用与描述他的 手抖 级别</span><br><span class="line">        // .....</span><br><span class="line">    &#125; attr ;</span><br><span class="line">    </span><br><span class="line">&#125; Node ;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32] ;</span><br><span class="line">    int Age ;</span><br><span class="line">    char Type ; // S 学生  T 老师  A 阿姨</span><br><span class="line"></span><br><span class="line">    // 在结构体中嵌套的联合体，用于描述不同类型的人物的属性</span><br><span class="line">    union </span><br><span class="line">    &#123;</span><br><span class="line">        float PerPoint ; // 如果是学生则用于描述学生的绩点 </span><br><span class="line">        char Level ; //  如果是一个老师则用于描述该老师 职称 A B C S </span><br><span class="line">        int Jitter ; // 如果是饭堂阿姨则用与描述他的 手抖 级别</span><br><span class="line">        // .....</span><br><span class="line">    &#125; attr ;</span><br><span class="line">    </span><br><span class="line">&#125; Node ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Node arr[5] =&#123;</span><br><span class="line">        &#123;&quot;Even&quot; , 19 , &#x27;T&#x27; , .attr.Level=&#x27;S&#x27; &#125;,</span><br><span class="line">        &#123;&quot;ErGou&quot; , 23 , &#x27;S&#x27; , .attr.PerPoint= 0.123 &#125;,</span><br><span class="line">        &#123;&quot;CuiHUa&quot; , 13 , &#x27;A&#x27; ,.attr.Jitter = 99 &#125;,</span><br><span class="line">        &#123;&quot;TieZhu&quot; , 65 , &#x27;S&#x27; , .attr.PerPoint = 0.0012&#125; ,</span><br><span class="line">        &#123;&quot;TieDan&quot; , 35 , &#x27;T&#x27; , .attr.Level= &#x27;A&#x27;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Name:%s\n&quot; , arr[i].Name);</span><br><span class="line">        printf(&quot;Age:%d\n&quot; , arr[i].Age);</span><br><span class="line">        printf(&quot;Type:%c\n&quot; , arr[i].Type);</span><br><span class="line"></span><br><span class="line">        switch (arr[i].Type)</span><br><span class="line">        &#123;</span><br><span class="line">            case &#x27;S&#x27;:</span><br><span class="line">                /* 这是一名学生 */</span><br><span class="line">                printf(&quot;PerPoint:%f\n&quot; , arr[i].attr.PerPoint );</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            case &#x27;T&#x27;:</span><br><span class="line">                /* 这是一名老师 */</span><br><span class="line">                printf(&quot;Level:%c\n&quot; , arr[i].attr.Level );</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            case &#x27;A&#x27;:</span><br><span class="line">                /* 这是一名阿姨 */</span><br><span class="line">                printf(&quot;Jitter:%d\n&quot; , arr[i].attr.Jitter );</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十五）结构体</title>
      <link href="/2024/02/27/15.%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2024/02/27/15.%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h4 id="结构体基本概念"><a href="#结构体基本概念" class="headerlink" title="结构体基本概念"></a><strong>结构体基本概念</strong></h4><p>​C语言提供了众多的基本类型，但现实生活中的对象一般都不是单纯的整型、浮点型或字符串，而是这些基本类型的综合体。比如一个学生，典型地应该拥有学号（整型）、姓名（字符串）、分数（浮点型）、性别（枚举）等不同侧面的属性，这些所有的属性都不应该被拆分开来，而是应该组成一个整体，代表一个完整的学生。</p><p>​在C语言中，可以使用结构体来将多种不同的数据类型组装起来，形成某种现实意义的自定义的变量类型。结构体本质上是一种自定义类型。</p><p>结构体的声明：</p><p>声明语句不是在生产某一个产品，只是向系统报备某一个类型的模型。后期通过该模型来定义变量才真正的分配内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体标签</span><br><span class="line">&#123;</span><br><span class="line">    成员1;</span><br><span class="line">    成员2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;  // 声明语句后面必须有一个分号代表该语句的结束</span><br></pre></td></tr></table></figure><ul><li><p>语法：</p></li><li><ul><li>结构体标签，用来区分各个不同的结构体。</li><li>成员，是包含在结构体内部的数据，可以是任意的数据类型。</li></ul></li></ul><p>结构体声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明结构体 。 声明语句不需要占用内存空间 </span><br><span class="line">struct BookNode</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32] ;</span><br><span class="line">    float Price ;</span><br><span class="line">    int Page ;</span><br><span class="line">    // .......</span><br><span class="line">&#125;;</span><br><span class="line">// 声明结构体 </span><br><span class="line">//声明语句不需要占用内存空间</span><br></pre></td></tr></table></figure><p>结构体定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用自己声明的结构体类型来定义变量</span><br><span class="line">//   变量的类型      变量名  ;</span><br><span class="line">int                 Num     ;</span><br><span class="line">struct BookNode     C       ; // 定义语句 才向系统申请内存空间</span><br></pre></td></tr></table></figure><p>结构体成员赋值及访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 如何给结构体中各个数据进行赋值</span><br><span class="line">// C.Name = &quot;Even&quot; ; // 【错误操作】 C.Name 实际上是一个数组的名字.....</span><br><span class="line">// char arr [32] ;</span><br><span class="line">// arr = &quot;Even&quot;;</span><br><span class="line"></span><br><span class="line">char * Name = &quot;Even&quot; ;</span><br><span class="line">int Len = strlen(Name);</span><br><span class="line">printf(&quot;Len:%d\n&quot; ,Len );</span><br><span class="line"></span><br><span class="line">// 使用内存拷贝函数对结构体中的数组进行赋值</span><br><span class="line">memcpy( C.Name , Name , Len+1 );</span><br><span class="line"></span><br><span class="line">// 可以直接使用赋值符号对普通的基础数据类型进行赋值</span><br><span class="line">C.Page = 100 ;</span><br><span class="line">C.Price = 230.57 ;</span><br><span class="line"></span><br><span class="line"> // 如何访问数据</span><br><span class="line">printf(&quot;Neme:%s Page:%d Price:%f\n&quot; , C.Name , C.Page , C.Price) ;</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240227134055948.png" alt="image-20240227134055948"></p><p>操作练习：</p><ul><li><p>尝试自行设计一个结构体用于描述一只猫的各项属性（性别、姓名、身高、身长、食量等）</p></li><li><p>尝试对猫进行赋值以及访问各项成员</p></li><li><p>可以尝试从键盘输入信息对猫的各项属性进行设置</p></li></ul><p> <img src="/imgs/$%7Bfiilename%7D/image-20240227134106316.png" alt="image-20240227134106316">   </p><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a><strong>结构体初始化</strong></h4><p>结构体的初始化与基础数据类型一样只有在定义语句中同时赋值，才称为初始化操作。</p><p>结构体的初始化一般有两种方法：</p><ul><li>方法一顺序初始化：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 结构体声明</span><br><span class="line">struct Cat</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32] ;</span><br><span class="line">    int Num ;</span><br><span class="line">    float Length;</span><br><span class="line">    float Height;</span><br><span class="line">    //....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Cat Huang = &#123; &quot;大黄&quot; , 32.67 , 45.66 &#125; ;</span><br><span class="line"></span><br><span class="line">int arr[5] = &#123; 1, 2, 3, 4, 5&#125; ;</span><br></pre></td></tr></table></figure><p>注意顺序初始化的操作写法，看着比较简洁，但是不太方便对代码进行升级迭代，比如在结构体的成员之间有添加新的成员，那么顺序初始化就不顺序了（初始化代码需要修改顺序..）。</p><p>因此<strong>为了项目的更新迭代更加方便具有更好的拓展性建议使用第二种初始化的方法（指定成员初始化）</strong></p><ul><li>指定成员初始化：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 指定成员初始化   . 成员引用符</span><br><span class="line">struct Cat Lv = &#123;</span><br><span class="line">    .Name = &quot;小绿&quot; ,</span><br><span class="line">    .Length = 123.435 ,</span><br><span class="line">    .Height = 5432.65 ,</span><br><span class="line">    .Sex = 1 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a><strong>结构体指针</strong></h4><p>概念： 它是一个指针， 他所指向的类型是一个结构体类型。</p><p>语法： struct  标签  * ptr ; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个结构体变量</span><br><span class="line">struct Node Even = &#123;</span><br><span class="line">    .Name = &quot;Even&quot;,</span><br><span class="line">    .Num = 12 ,</span><br><span class="line">    .Sex = true  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义了一个结构体类型的指针变量， 并把 even 的地址存入到该变量中</span><br><span class="line">struct Node * ptr  = &amp;Even ;</span><br><span class="line"></span><br><span class="line">// 如何通过结构体指针来访问结构体中的各个成员</span><br><span class="line">// -&gt;  结构体指针的成员引用符</span><br><span class="line">printf(&quot;Name:%s Num:%d Sex:%d\n&quot; , ptr-&gt;Name , ptr-&gt;Num , ptr-&gt;Sex );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 如何在堆内存中申请结构体的内存空间并合理利用它</span><br><span class="line">struct Node * ptr1 = calloc(1 , sizeof(struct Node));</span><br><span class="line"></span><br><span class="line">// 使用字符串拷贝函数 把 数据 &quot;Even&quot; 拷贝到 ptr1-&gt;Name 数组中， 最大拷贝32字节 。</span><br><span class="line">strncpy( ptr1-&gt;Name , &quot;Even&quot; , 32 );</span><br><span class="line"></span><br><span class="line">ptr1-&gt;Num = 10 ;</span><br><span class="line"></span><br><span class="line">ptr1-&gt;Sex = false ; </span><br><span class="line"></span><br><span class="line">printf(&quot;Name:%s Num:%d Sex:%d\n&quot; , </span><br><span class="line">            ptr1-&gt;Name , ptr1-&gt;Num , ptr1-&gt;Sex );</span><br><span class="line"></span><br><span class="line">// 释放堆中的结构体内存</span><br><span class="line">free(ptr1) ;</span><br><span class="line">ptr1 = NULL ;</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">添加头文件</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a><strong>结构体数组</strong></h4><p>概念： 他是一个数组，该数组中的每一个元素都是一个结构体 。</p><p>语法： struct Node arr [5] ; </p><p>如何定义并初始化结构体数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 使用结构体类型来定义一个数组Cats</span><br><span class="line">struct Node Cats [5] = &#123; </span><br><span class="line">    &#123;</span><br><span class="line">        .Name = &quot;大黄&quot;,</span><br><span class="line">        .Num = 1 ,</span><br><span class="line">        .Type = &#x27;M&#x27; </span><br><span class="line">    &#125; , </span><br><span class="line">    &#123;</span><br><span class="line">        .Name = &quot;小绿&quot;,</span><br><span class="line">        .Num = 2 ,</span><br><span class="line">        .Type = &#x27;M&#x27;</span><br><span class="line">    &#125; , </span><br><span class="line">    &#123; &quot;啊狗&quot; , 3 , &#x27;G&#x27; &#125; ,</span><br><span class="line">    &#123; &quot;啊猫&quot; , 4 , &#x27;G&#x27; &#125; ,</span><br><span class="line">    &#123; &quot;翠花&quot; , 5 , &#x27;M&#x27;&#125;</span><br><span class="line">    </span><br><span class="line">&#125; ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何访问结构体数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;************正常访问结构体数组****************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; 5 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Name:%s Num:%d Type:%c\n&quot; , Cats[i].Name , (*(Cats+i)).Num , (Cats+i)-&gt;Type );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;************使用结构体指针来访问结构体数组****************\n&quot;);</span><br><span class="line">// 定义一个结构体指针 ，并让该指针指向了结构体数组 Cats 的第一个元素的入口地址（首元素的首地址）</span><br><span class="line">struct Node * ptr = Cats ;</span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;Name:%s Num:%d Type:%c\n&quot; , </span><br><span class="line">        (ptr+i)-&gt;Name , (*(ptr+i)).Num , ptr[i].Type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;************使用结构体指针数组来访问结构体数组****************\n&quot;);</span><br><span class="line">// 结构体数组指针 （ 它是一个指针， 该指针指向一个数组，该数组的每一个元素都是结构体类型 ）</span><br><span class="line">struct Node (* ptr1) [5] = &amp;Cats ;</span><br><span class="line"></span><br><span class="line">// ptr1 ==== &amp; Cats</span><br><span class="line">// *ptr1 ==== *&amp; Cats</span><br><span class="line">//  *ptr1 === Cats</span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;Name:%s Num:%d Type:%c\n&quot; , </span><br><span class="line">        (*ptr1)[i].Name , ((*ptr1)+i)-&gt;Num , (*((*ptr1)+i)).Type );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体声明语句变形"><a href="#结构体声明语句变形" class="headerlink" title="结构体声明语句变形"></a><strong>结构体声明语句变形</strong></h4><p>型态一：</p><p>​在声明结构体的同时，定义变量（可以是多个，也可以是指针，甚至可以是数组….）</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明结构变量类型</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32];</span><br><span class="line">    int Num ;</span><br><span class="line">    char Type ;</span><br><span class="line">&#125; 变量名 , ....   ;  // 在分号以及大括号之间写上需要定义的变量名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明结构变量类型</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32];</span><br><span class="line">    int Num ;</span><br><span class="line">    char Type ;</span><br><span class="line">&#125; Cat1 , Cat2 , *ptr  ;  // 在声明的同时定义了两个 结构体变量， 以及一个结构体指针</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>   所有的指针或变量由于都是在函数体外面定义的，因此他们都是全局变量</p></blockquote><p>型态二：</p><p>把结构体的标签名字省略，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明结构变量类型</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    char Name [32];</span><br><span class="line">    int Num ;</span><br><span class="line">    char Type ;</span><br><span class="line">&#125; Cat1 , Cat2 , *ptr , arr[5] ;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>​这种形态的结构体类型，只能通过声明语句一起来定义变量， 其他地方无法定义这种类型的结构体变量。</p></blockquote><p>型态三：</p><p>使用typedef 来对结构体类型进行取别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 声明结构变量类型  </span><br><span class="line">//  使用typedef 来给 struct Node 取别名为  Cat </span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    char Name [32];</span><br><span class="line">    int Num ;</span><br><span class="line">    char Type ;</span><br><span class="line">&#125; Cat , *P_Cat ;</span><br><span class="line">// Cat   就等价于   struct Node  是结构体的类型名</span><br><span class="line">// P_Cat 就等价于   struct Node *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用别名 Cat 来定义变量 mao </span><br><span class="line">Cat mao = &#123;</span><br><span class="line">    .Name = &quot;条条猫&quot;,</span><br><span class="line">    .Num = 12 ,</span><br><span class="line">    .Type = &#x27;M&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printf(&quot;Name:%s Num:%d Type:%c\n&quot; , mao.Name , mao.Num , mao.Type );</span><br><span class="line"></span><br><span class="line">// 使用别名 P_Cat 来定义指针ptr </span><br><span class="line">P_Cat ptr = &amp;mao ;</span><br><span class="line">printf(&quot;Name:%s Num:%d Type:%c\n&quot; , ptr-&gt;Name , ptr-&gt;Num , ptr-&gt;Type );</span><br></pre></td></tr></table></figure><p>注意：</p><p>​关注声明语句前面有没有关键字 typedef 如果有则表示取别名，如果没有则表示顺便定义变量。</p><h4 id="结构体的嵌套"><a href="#结构体的嵌套" class="headerlink" title="结构体的嵌套"></a><strong>结构体的嵌套</strong></h4><p>​概念： 在结构体中有每一个或多个成员是其他的结构体</p><p>​语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">    int Num ;</span><br><span class="line">    char Name[32];</span><br><span class="line">    struct &#123;</span><br><span class="line">       .......     </span><br><span class="line">    &#125; info  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">    int Num ;</span><br><span class="line">    char Name[32];</span><br><span class="line"></span><br><span class="line">    // 嵌套在结构体中的小结构体</span><br><span class="line">    struct &#123;</span><br><span class="line">       char type ;</span><br><span class="line">       int Test ;  </span><br><span class="line">    &#125; info  ;</span><br><span class="line"></span><br><span class="line">&#125; Node , *P_Node  ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Node mao = &#123;</span><br><span class="line">        .Name = &quot;翠翠&quot;,</span><br><span class="line">        .Num = 10 ,</span><br><span class="line">        .info.Test = 123 ,</span><br><span class="line">        .info.type = &#x27;P&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Name:%s Num:%d Test:%d Type:%c\n&quot; , </span><br><span class="line">            mao.Name , mao.Num , mao.info.Test , mao.info.type );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CPU字长"><a href="#CPU字长" class="headerlink" title="CPU字长"></a><strong>CPU字长</strong></h4><p>​字长的概念指的是处理器在一条指令中的数据处理能力，当然这个能力还需要搭配操作系统的设定，比如常见的32位系统、64位系统，指的是在此系统环境下，处理器一次存储处理的数据可以达32位或64位。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240227134536381.png" alt="image-20240227134536381"></p><h4 id="地址对齐"><a href="#地址对齐" class="headerlink" title="地址对齐"></a><strong>地址对齐</strong></h4><p>​CPU字长确定之后，相当于明确了系统每次存取内存数据时的边界，以32位系统为例，32位意味着CPU每次存取都以4字节为边界，因此每4字节可以认为是CPU存取内存数据的一个单元。</p><p>​如果存取的数据刚好落在所需单元数之内，那么我们就说这个数据的地址是对齐的，如果存取的数据跨越了边界，使用了超过所需单元的字节，那么我们就说这个数据的地址是未对齐的。</p><p>地址未对齐的情形</p><p> <img src="/imgs/$%7Bfiilename%7D/image-20240227134618107.png" alt="image-20240227134618107"></p><p>​从图中可以明显看出，数据本身占据了8个字节，在地址未对齐的情况下，CPU需要分3次才能完整地存取完这个数据，但是在地址对齐的情况下，CPU可以分2次就能完整地存取这个数据。</p><p>总结：如果一个数据满足以最小单元数存放在内存中，则称它地址是对齐的，否则是未对齐的。<strong>地址对齐的含义</strong>用大白话说就是<strong>1个单元能塞得下的就不用2个</strong>；2个单元能塞得下的就不用3个。如果发生数据地址未对齐的情况，有些系统会直接罢工，有些系统则降低性能。</p><h4 id="普通变量的m值"><a href="#普通变量的m值" class="headerlink" title="普通变量的m值"></a><strong>普通变量的m值</strong></h4><p>​以32位系统为例，由于CPU存取数据总是以4字节为单元，因此对于一个尺寸固定的数据而言，当它的地址满足某个数的整数倍时，就可以保证地址对齐。这个数就被称为变量的m值。</p><p>​根据具体系统的字长，和数据本身的尺寸，m值是可以很简单计算出来的。</p><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char   c; // 由于c占1个字节，因此c不管放哪里地址都是对齐的，因此m=1</span><br><span class="line">short  s; // 由于s占2个字节，因此s地址只要是偶数就是对齐的，因此m=2</span><br><span class="line">int    i; // 由于i占4个字节，因此只要i地址满足4的倍数就是对齐的，因此m=4</span><br><span class="line">double f; // 由于f占8个字节，因此只要f地址满足4的倍数就是对齐的，因此m=4</span><br><span class="line">    //   如果是 64位的系统 那么8个字节的数据的M值是 8 </span><br><span class="line"></span><br><span class="line">printf(&quot;%p\n&quot;, &amp;c); // &amp;c = 1*N，即：c的地址一定满足1的整数倍</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;s); // &amp;s = 2*N，即：s的地址一定满足2的整数倍</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;i); // &amp;i = 4*N，即：i的地址一定满足4的整数倍</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;f); // &amp;f = 4*N，即：f的地址一定满足4的整数倍</span><br></pre></td></tr></table></figure><ul><li><p>注意，变量的m值跟变量本身的尺寸有关，但它们是两个不同的概念。</p></li><li><p>手工干预变量的m值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c __attributr__((alisgned(32))); //将变量c的m值设置为32</span><br></pre></td></tr></table></figure></li><li><p>语法：</p><ul><li><p>attribute 机制是GNU特定语法，属于C语言标准语法的扩展。</p></li><li><p>attribute 前后都是<strong>双下划线 “__”</strong>，aligned两边是<strong>双圆括号 “(())”。</strong></p></li><li><p>attribute 语句，出现在变量定义语句中的<strong>分号前面</strong>，<strong>变量标识符的后面</strong></p></li><li><p>attribute 机制支持<strong>多种属性设置</strong>，其中 aligned 用来设置变量的 m 值属性。</p></li><li><p>一个变量的 m 值只能<strong>提升，不能降低</strong>，且只能为正的2的n次幂。</p></li></ul></li><li><p>可以参考<a href="https://blog.csdn.net/weixin_37867857/article/details/102940773">https://blog.csdn.net/weixin_37867857/article/details/102940773</a></p></li></ul><h4 id="结构体的M值"><a href="#结构体的M值" class="headerlink" title="结构体的M值"></a><strong>结构体的M值</strong></h4><ul><li><p>概念：</p></li><li><ul><li>结构体的M值，取决于其成员的m值的最大值。即：M &#x3D; max{m1, m2, m3, …};</li><li>结构体的地址和尺寸，都必须等于M值的整数倍。</li></ul></li><li><p>示例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    short  a; // 尺寸=2，m值=2</span><br><span class="line">    double b; // 尺寸=8，m值=4 / 8 </span><br><span class="line">    char   c; // 尺寸=1，m值=1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node n; // M值 = max&#123;2, 4, 1&#125; = 4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>以上结构体成员存储分析：</li></ul><ol><li>结构体的M值等于4或8，这意味着结构体的地址、尺寸都必须满足4或8的倍数。</li><li>成员a的m值等于2，<strong>但a作为结构体的首元素</strong>（首元素的地址等于结构体的入口地址），必须满足M值约束，即<strong>a的地址必须是4或8的倍数</strong></li><li>成员b的m值等于4，因此在a和b之间，需要填充2个字节的无效数据（为了成员b的地址值能被他自己的M值所整除）（一般填充0）</li><li>成员c的m值等于1，因此c紧挨在b的后面，占一个字节即可。</li><li>结构体的M值为4，因此成员c后面还需填充3个无效数据，才能将结构体尺寸凑足4的倍数。</li></ol><p> <img src="/imgs/$%7Bfiilename%7D/image-20240305142240388.png" alt="image-20240305142240388"></p><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a><strong>可移植性</strong></h4><p>可移植指的是相同的一段数据或者代码，在不同的平台中都可以成功稳定运行。</p><ul><li><p>对于数据来说，有两方面可能会导致不可移植：</p></li><li><ul><li>数据尺寸发生变化 比如long 类型</li><li>数据存储位置发生变化 （特别实在结构体中各个数据之间的相对位置）</li></ul></li></ul><p>​第一个问题，起因是基本的数据类型在不同的系统所占据的字节数不同造成的，解决办法是使用教案04讨论过的可移植性数据类型即可。本节主要讨论第二个问题。</p><p>考虑结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int8_t  a;</span><br><span class="line">    int32_t b;</span><br><span class="line">    int16_t c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​以上结构体，在不同的的平台中，成员的尺寸是固定不变的，但由于不同平台下各个成员的m值可能会发生改变，因此成员之间的相对位置可能是飘忽不定的，这对数据的可移植性提出了挑战。</p><p>解决的办法有两种：</p><ul><li>第一，固定每一个成员的m值，也就是每个成员之间的塞入固定大小的填充物固定位置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    __int8_t  a __attribute__((aligned(1))); // 将 m 值固定为1</span><br><span class="line">    __int64_t b __attribute__((aligned(8))); // 将 m 值固定为8</span><br><span class="line">    __int16_t c __attribute__((aligned(2))); // 将 m 值固定为2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第二，将结构体压实，也就是每个成员之间不留任何空隙：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    __int8_t  a;</span><br><span class="line">    __int64_t b;</span><br><span class="line">    __int16_t c;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>总结：</p><p>以上两种方法的优缺点：</p><ul><li><p>固定每一个成员的m值： 优点是结构体中每一个成员的存储位置依然是符合地址对齐的规则的，访问效率依然存在</p></li><li><p>将结构体压实： 优点是结构体中每一个成员都只占用实际的大小，不需要为了地址对齐而填充空白，访问的效率相对要低一些</p></li></ul><p>【拓展】结构体中的占位符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int a:4 ; // a 占用 4 个二进制位</span><br><span class="line">    char b:2 ; //b 占用2个二进制位</span><br><span class="line">    char c:8 ; // c 占用8个二进制位</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int a:4 ;  // a 值占用 4 个二进制位</span><br><span class="line">    char b:2 ; // b占用两个二进制位</span><br><span class="line">    char c:8 ; // c占用8个二进制位</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%ld\n&quot; , sizeof(struct Node));//4</span><br><span class="line"></span><br><span class="line">    Node data ;</span><br><span class="line">    int Num = 1172 ;</span><br><span class="line"></span><br><span class="line">    memcpy( &amp;data , &amp;Num , 4 );</span><br><span class="line"></span><br><span class="line">    printf(&quot;data.a:%d\n&quot;,data.a);//4</span><br><span class="line">    printf(&quot;data.b:%d\n&quot;,data.b);//-7</span><br><span class="line">    printf(&quot;data.c:%d\n&quot;,data.c);//4</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十四）字符串处理函数</title>
      <link href="/2024/02/27/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/27/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><h4 id="字符指针与字符串"><a href="#字符指针与字符串" class="headerlink" title="字符指针与字符串"></a><strong>字符指针与字符串</strong></h4><ol><li><strong>字符指针的概念</strong></li></ol><p>​字符指针是指向字符类型数据的指针。它可以用于<strong>存储字符串的起始地址</strong>，通过指针，我们可以访问和操作字符串的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strPtr;   // 声明一个字符指针</span><br></pre></td></tr></table></figure><p>上述代码声明了一个字符指针strPtr，它可以指向一个字符类型的数据。</p><ol start="2"><li><strong>字符串的概念</strong><br>字符串是由字符序列组成的数据，以null字符(‘\0’)结尾。在C语言中，字符串通常用字符数组表示。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char strArray[6] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure><p>上述代码声明了一个字符数组strArray，它存储了一个字符串”Hello”。</p><ol start="3"><li><strong>字符指针和字符串的关系</strong></li></ol><p>  通过将字符指针指向字符串的起始地址，我们可以使用字符指针来访问和操作字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *strPtr;   // 声明一个字符指针</span><br><span class="line">char strArray[6] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">strPtr = strArray;   // 字符指针指向字符串的起始地址</span><br><span class="line"></span><br><span class="line">printf(&quot;%p\n&quot;, strPtr);   //打印字符指针指向字符串的起始地址</span><br><span class="line">printf(&quot;%s\n&quot;, strPtr);   // 打印字符指针指向的字符串</span><br><span class="line">//输出结果：Hello</span><br></pre></td></tr></table></figure><p>在上述代码中，我们将字符指针strPtr指向字符数组strArray，然后使用printf函数打印字符指针指向的字符串。</p><ol start="4"><li><strong>字符串的输入和输出</strong></li></ol><ul><li>输入字符串</li></ul><p>  使用scanf函数可以输入字符串，并将其存储在字符数组中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char strArray[20];</span><br><span class="line">scanf(&quot;%s&quot;, strArray);</span><br></pre></td></tr></table></figure><p>上述代码中，scanf函数用于输入字符串，并将其存储在字符数组strArray中。</p><ul><li>输出字符串</li></ul><p>  使用printf函数可以输出字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char strArray[6] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br><span class="line">printf(&quot;%s\n&quot;, strArray);</span><br><span class="line">//输出结果：Hello</span><br></pre></td></tr></table></figure><p>在上述代码中，printf函数用于输出字符串。</p><h4 id="函数strstr（）"><a href="#函数strstr（）" class="headerlink" title="函数strstr（）"></a><strong>函数strstr（）</strong></h4><p>功能：在一个字符串中寻找指定的字串</p><p>函数的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line">函数原型：</span><br><span class="line">    char *strstr(const char *haystack, const char *needle);</span><br><span class="line">参数分析：</span><br><span class="line">    haystack  --&gt;  需要寻找的母串</span><br><span class="line">    needle --&gt; 需要查找的子串</span><br><span class="line">        白话文： 在字符串 haystack 查找 是否有出现  needle ，如果有则返回needle第一次出现的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功 返回第一次出现的地址</span><br><span class="line">    失败 返回NULL </span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char * msg = &quot;char *strstr(const char char *strstr(const char *haystack, const char *needle); *haystack, const char *needle);&quot;;</span><br><span class="line"></span><br><span class="line">char * p = &quot;const&quot;;</span><br><span class="line"></span><br><span class="line">char * p_ret = strstr( msg , p );</span><br><span class="line"></span><br><span class="line">if ( p_ret != NULL )</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;成功找到子串，他第一次出现的地址：%p\n&quot; , p_ret);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    printf(&quot;无法在字符串msg中找到子串...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;msg:%p p_ret:%p\n&quot; , msg , p_ret);</span><br></pre></td></tr></table></figure><h4 id="函数strlen"><a href="#函数strlen" class="headerlink" title="函数strlen"></a><strong>函数strlen</strong></h4><p>作用： 用于计算一个指定的字符串的长度。（计算的标准是从指定分入口地址开始一直往后面计算直到遇到 \0 结束符为止，且\0不计算在内）</p><blockquote><p>注意：strlen与sizeof（）的区别：</p><p>​  sizeof():计算变量大小，由系统的位数决定。</p></blockquote><p>函数分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line">函数原型：</span><br><span class="line">    size_t strlen(const char *s);</span><br><span class="line"> 参数分析：</span><br><span class="line">    s --&gt; 需要计算长度的入口地址</span><br><span class="line"> 返回值：</span><br><span class="line">    返回字符串s 的长度 （不包括结束符）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数strtok"><a href="#函数strtok" class="headerlink" title="函数strtok"></a><strong>函数strtok</strong></h4><p>作用：用于对指定字符串按照指定的分隔符进行分隔。</p><p>注意: </p><ul><li>该函数会修改指针S所指向的内存的内容<ul><li><p>第一个参数s在第一次调用分割函数的时候必须传递实参</p></li><li><p><strong>以后每一次调用的第一个参数都必须写 NULL</strong> 让他在上一次的基础上继续分割</p></li><li><p>如果每一次调用都给了实际参数那么则会从新初始化需要分割目标字符串</p></li></ul></li></ul><p>函数分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">头文件 ：</span><br><span class="line">    #include &lt;string.h&gt; </span><br><span class="line">定义函数 </span><br><span class="line">    char * strtok(char *s, const char *delim);  </span><br><span class="line">参数分析：</span><br><span class="line">    s --&gt; 需要分割的目标字符串 [该指针指向的内存必须是可读写的] (不允许只读)</span><br><span class="line">    delim --&gt; 指定的分隔符 （常目标指针）</span><br><span class="line">返回值：</span><br><span class="line">    成功 该函数返回被分解的第一个子字符串</span><br><span class="line">    失败 或无法再进行分隔这 返回NULL </span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>char * ret_val &#x3D;  strtok(arr , “* “);&#x2F;&#x2F;其中*和空格都会被单独当作分隔符</p></blockquote><h4 id="函数strcat与strncat"><a href="#函数strcat与strncat" class="headerlink" title="函数strcat与strncat"></a><strong>函数strcat与strncat</strong></h4><p><img src="/imgs/$%7Bfiilename%7D/image-20240305163240001.png" alt="image-20240305163240001"></p><ul><li>注意：</li></ul><ol><li><p>这两个函数的功能，都是将 src 中的字符串，复制拼接到 dest 的末尾。</p></li><li><p>strcat() 没有边界控制，因此可能会由于 src 的过长而导致内存溢出（结束条件只有一个 就是遇到src中的结束符 ‘\0’）。</p></li><li><p>strncat() 有边界控制，最多复制 n+1 个字符（其中最后一个是 ‘\0’ ）到 dest 的末尾</p></li></ol><ul><li>结束条件：<ol><li>遇到SRC结束符</li><li>达到 N +1的大小 （+1 是为了留空结束符）</li></ol></li></ul><h4 id="函数strcpy与strncpy"><a href="#函数strcpy与strncpy" class="headerlink" title="函数strcpy与strncpy    "></a><strong>函数strcpy与strncpy</strong>    <img src="/imgs/$%7Bfiilename%7D/image-20240305163302492.png" alt="0"></h4><p><strong>注意：</strong></p><ul><li><p>strcpy 与strncpy 都是用于把src字符串拷贝到 dest 中</p></li><li><p>区别在于strcpy 只有一个结束调节就是遇到 src中的结束符， 因此可能会导致拷贝过程中出现溢出的问题</p></li><li><p>而strncpy 则有两个结束条件， 一个是遇到 src中的结束符 ， 另一个则是 满足用户的期望字节数</p></li><li><p>注意strncpy 在拷贝的时候不会主动增加结束符  \0</p></li></ul><h4 id="函数strcmp与strncmp"><a href="#函数strcmp与strncmp" class="headerlink" title="函数strcmp与strncmp    "></a><strong>函数strcmp与strncmp</strong>    <img src="/imgs/$%7Bfiilename%7D/image-20240305163314449.png" alt="0"></h4><p>注意：</p><ul><li><p>这两个函数都是用来比较字符串是否相等</p></li><li><p>strcmp 比较时的结束条件只有两个  遇到结束符或遇到不相同的字符</p></li><li><p>strncmp 比较时的结束条件只有三个 遇到结束符或遇到不相同的字符 以及达到用户指定的数量</p></li></ul><h4 id="函数strchr与strrchr"><a href="#函数strchr与strrchr" class="headerlink" title="函数strchr与strrchr    "></a><strong>函数strchr与strrchr</strong>    <img src="/imgs/$%7Bfiilename%7D/image-20240305163331351.png" alt="0"></h4><ul><li><p>注意：</p></li><li><ol><li>这两个函数的功能，都是在指定的字符串 s 中，试图找到字符 c。</li><li>strchr() 从左往右找，找第一个出现的字符。</li><li>strrchr() 从左往右找，找最后一个出现的字符，返回它的指针。</li><li>字符串结束标记 ‘\0’ 被认为是字符串的一部分。</li></ol></li></ul><h4 id="函数memcmp"><a href="#函数memcmp" class="headerlink" title="函数memcmp"></a><strong>函数memcmp</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 头文件：</span><br><span class="line">     #include &lt;string.h&gt;</span><br><span class="line">函数原型:</span><br><span class="line">   int memcmp(const void *s1, const void *s2, size_t n);</span><br><span class="line">参数分析：</span><br><span class="line">    s1 --&gt; 需要比较的内存1 </span><br><span class="line">    s2 --&gt; 需要比较的内存2</span><br><span class="line">    n --&gt;  期望比较的内存大小 n字节</span><br><span class="line">返回值：</span><br><span class="line">    返回差值  0 表示相等</span><br></pre></td></tr></table></figure><h4 id="memcmp-与-strcmp-的区别"><a href="#memcmp-与-strcmp-的区别" class="headerlink" title="memcmp 与 strcmp 的区别:"></a><strong>memcmp 与 strcmp 的区别:</strong></h4><ul><li><p>strncmp 的结束条件有： 出现差异 + 遇到结束符 + 用户指定比较的长度</p></li><li><p>memcmp 的结束条件有： 出现差异 + 用户指定比较的长度</p></li></ul><h4 id="函数memcpy"><a href="#函数memcpy" class="headerlink" title="函数memcpy"></a><strong>函数memcpy</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">头文件 ：</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line">函数原型：</span><br><span class="line">    void *memcpy(void *dest, const void *src, size_t n);</span><br><span class="line">参数分析：</span><br><span class="line">    dest --&gt; 拷贝数据的目标地址</span><br><span class="line">    src --&gt; 需要拷贝的原始数据</span><br><span class="line">    n --&gt; 期望拷贝的字节数</span><br><span class="line">返回值：</span><br><span class="line">    返回参数 dest</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>memcpy 与 strcpy 的区别</p></li><li><p>strcpy ： 以结束符  ‘\0’ 为拷贝结束的标记</p></li><li><p>memcpy ： 以用户的期望值为标记</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十三）特殊函数</title>
      <link href="/2024/02/27/13.%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/27/13.%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><p><strong>静态函数</strong></p><ul><li><p>背景知识：普通函数都是跨文件可见的，即在文件 a.c 中定义的函数可以在 b.c 中使用。</p></li><li><p>静态函数：只能在定义的文件内可见的函数，称为静态函数。</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void f(void) // 在函数头前面增加关键字 static ，使之成为静态函数</span><br><span class="line">&#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>要点：</p><ul><li><p>静态函数主要是为了缩小函数的可见范围，减少与其他文件中重名函数冲突的概率。</p></li><li><p>静态函数一般被定义在头文件中，然后被各个源文件包含。</p></li></ul></li></ul></li></ul><p><strong>递归函数</strong></p><ul><li><p>递归概念：如果一个函数内部，包含了对自身的调用，则该函数称为递归函数。</p></li><li><p>递归问题：</p></li><li><ul><li>阶乘。</li><li>幂运算。</li><li>字符串翻转。</li></ul></li><li><p>要点：</p></li><li><ul><li>只有能被表达为递归的问题，才能用递归函数解决。</li><li>递归函数<strong>必须有一个可直接退出的 条件</strong>，否则会进入无限递归。</li><li>递归函数包含两个过程，一个逐渐递进的过程，和一个逐渐回归的过程。</li></ul></li><li><p>示例：依次输出 n 个自然数。</p></li><li><ul><li>假设用户输入 5 ，那么代码则输出 1-5的数字</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240227130741264.png" alt="image-20240227130741264"></p><ul><li>递归调用时，函数的栈内存的变化如下图所示。</li><li>可见，随着递归函数的层层深入，栈空间逐渐往下增长，如果递归的层次太深，很容易把栈内存耗光（栈溢出的错误导致程序崩溃）。</li><li>层层递进时，问题的规模会随之减小，减小到可直接退出的条件时，函数开始层层回归。</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240227130753011.png" alt="image-20240227130753011"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240227130800812.png" alt="image-20240227130800812"></p><p>作业：</p><ul><li>写出下面所描述的各个函数的声明语句：</li></ul><ol><li>函数 f1 接受一个 int 类型的参数，没有返回值。 void   f1 ( int ) ;</li><li>函数 f2 接受两个 int 类型的参数，并返回一个 int 型数据。  int f2 （int， int）；</li><li>函数 f3 不接收任何参数，也不返回任何数据。  void f3 (void) ;</li></ol><ul><li><p>编写一个函数，使其返回3个整型参数中的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Func( int a, int b, int c )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int max = a&gt;b? a:b; </span><br><span class="line">    max = max&gt;c ? max:c ;</span><br><span class="line"></span><br><span class="line">    return max ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尝试编写递归函数实现：</p><ul><li>正数的幂</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 第二种，用递归思维方式解题：</span><br><span class="line">float myPower2(float base, int exp)</span><br><span class="line">&#123;</span><br><span class="line">    if(exp == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    </span><br><span class="line">    return myPower2(base, exp-1) * base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阶乘</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int factorial(int Num)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if ( Num == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return factorial(Num-1) * Num ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>观察 《memory_test.c》代码中的函数，指出它们的问题及时  尝试解决</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240229145339906.png" alt="image-20240229145339906"></p><p><strong>回调函数（钩子函数）</strong></p><ul><li>概念：函数实现方(函数的设计者)不调用该函数，而由函数接口提供方间接调用（第三方）的函数，称为回调函数。</li><li>示例：系统中的信号处理，是一个典型的利用回调函数的情形。</li></ul><p>信号处理</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240227132819254.png" alt="image-20240227132819254"></p><ul><li><p>要点：</p></li><li><ul><li>示例中函数 sighandler 是回调函数。</li><li>signal() 将回调函数的地址传递给内核，使得内核可以在恰当的时机回调 sighandler。</li><li>应用开发者和内核开发者只要约定好回调函数的接口，即可各自开发，进度互不影响。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十二）函数</title>
      <link href="/2024/02/25/12.%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/25/12.%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数入门"><a href="#函数入门" class="headerlink" title="函数入门&#x3D;&#x3D;&#x3D;"></a><strong>函数入门</strong>&#x3D;&#x3D;&#x3D;</h4><p>在C语言中，函数意味着功能模块。一个典型的C语言程序，就是的功能模块拼接起来的整体。也因为如此，C语言被称为模块化语言。</p><p>对于函数的使用者，可以简单地将函数理解为一个黑箱，使用者只管按照规定给黑箱一些输入，就会得到一些输出，而不必理会黑箱内部的运行细节。</p><p>​    <img src="data:image/png;base64,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" alt="0"></p><p>日常使用的电视机可以被理解为一个典型的黑箱，它有一些公开的接口提供给使用者操作，比如开关、音量、频道等，使用者不需要理会其内部电路，更不需要管电视机的工作原理，只需按照规定的接口操作接口得到结果。</p><p>电视机</p><img src="/imgs/$%7Bfiilename%7D/image-20240225224919317.png" alt="image-20240225224919317" style="zoom: 33%;" /><p>对于函数的设计者，最重要的工作是封装，封装意味着对外提供服务并隐藏细节。对于一个封装良好的函数而言，其对外提供服务的接口应当是简洁的，内部功能应当是明确的（模块功能要尽可能独立）。</p><p>我们自己在设计函数接口的时候应当尽可能做到 高内聚 、低耦合：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240225225025614.png" alt="image-20240225225025614"></p><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><strong>函数的定义</strong></h4><ul><li><p>函数头：函数对外的公开接口</p><ol><li>函数名称：命名规则与跟变量一致，一般取与函数实际功能相符合的、顾名思义的名称。</li><li>参数列表：即黑箱的输入数据列表，一个函数可有一个或多个参数，也可以不需要参数。</li><li>返回类型：即黑箱的输出数据类型，一个函数可不返回数据，但最多只能返回一个数据。</li></ol></li><li><p>函数体 {   }：函数功能的内部实现</p></li><li><p>语法说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名称(参数1, 参数2, ……)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如何自定义函数（自己设计函数）：</p><ol><li><p>在设计函数之前应该先想清楚该函数具体实现什么功能。</p></li><li><p>想清楚该函数设计出来之后应该入使用。</p></li><li><p>进入函数的具体设计阶段 </p><p>a.先思考好如何实现（实现该功能的每一个步骤）</p><p>b.按照实现想好的步骤填充代码</p></li></ol><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">int DisplayInt ( int Num )</span><br><span class="line">&#123; // 函数体的开始</span><br><span class="line"></span><br><span class="line">    printf(&quot;这里是整型输出函数...\n&quot; );</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Num:%d\n&quot; , Num );</span><br><span class="line"></span><br><span class="line">    return 123456 ;</span><br><span class="line">&#125; // 函数体的结束</span><br><span class="line"></span><br><span class="line">bool DisplayChar( char * msg )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;这里是字符串输出函数...\n&quot; );</span><br><span class="line">    </span><br><span class="line">    printf(&quot;msg:%s\n&quot; , msg );</span><br><span class="line"></span><br><span class="line">    return true ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 专门用于输出一个整形数据的函数</span><br><span class="line">    int RetVal = DisplayInt( 123 );</span><br><span class="line">    printf(&quot;函数DisplayInt返回的数据是：%d\n&quot; , RetVal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 专门用于输出一个字符串数据的函数</span><br><span class="line">    bool B = DisplayChar( &quot;Hello GZ2301&quot; );</span><br><span class="line">    if (B)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;字符串输出函数执行成功。。。\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;字符串输出函数执行失败。。。\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>语法汇总：</p><ol><li><p>当函数的参数列表为 void 时，表示该函数不需要任何参数。</p></li><li><p>当函数的返回类型为 void 时，表示该函数不返回任何数据。</p></li><li><p>当函数的返回类型为 void  * 时，表示该函数返回的是一个指针，只不过该指针所指向的类型是不确定的（通用类型地址）。</p></li><li><p>关键字 return 表示退出函数。</p><p>①若函数头中规定有返回数据类型，则 return 需携带一个类型与之匹配的数据；</p><p>②若函数头中规定返回类型为 void，则 return 不需携带参数。</p></li></ol></li></ul><h4 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a><strong>实参与形参</strong></h4><ul><li>概念：</li><li>函数调用中的参数，被称为实参（实际传递的参数），即 arguments</li></ul><p>​int max &#x3D; Max ( a , b );</p><p>​函数定义中的参数，被称为形参（形式参数），即 parameters</p><p>​int Max ( int x  , int y ) </p><p>​{   </p><p>​….. </p><p>​}</p><ul><li><p>实参与形参的关系：</p><ul><li><p>实参于形参的 类型 和 个数 以及 顺序 必须一一对应。</p></li><li><p>形参的值由实参初始化。</p></li><li><p>形参与实参位于不同的内存区域（各自在各自函数的栈空间中），彼此独立。</p></li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240225225138354.png" alt="image-20240225225138354"></p><p>练习操作：</p><ul><li><p>函数示例1：</p></li><li><ul><li>参数输入两个整型参数</li><li>函数功能中计算得到两个整型中较大的值</li><li>函数返回相对大的数据</li><li>函数内输出他们的和</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int Max ( int x  , int y )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 计算得到较大值</span><br><span class="line">    int m = x &gt; y ? x : y ;</span><br><span class="line"></span><br><span class="line">    // 输出较大值</span><br><span class="line">    printf(&quot;较大值：%d\n&quot; , m );</span><br><span class="line"></span><br><span class="line">    // 输出它们的和</span><br><span class="line">    printf(&quot;它们的和：%d\n&quot; , x + y);</span><br><span class="line"></span><br><span class="line">    // 返回较大值</span><br><span class="line">    return m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a><strong>函数的参数传递</strong></h4><p>​参数值传递： 函数在调用的时候实参是一个数据的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void  func( int k )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;k:%d\n&quot; , k );</span><br><span class="line">    k+= 100 ;</span><br><span class="line">    printf(&quot;k:%d\n&quot; , k );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/////主函数片段////</span><br><span class="line">int a = 123 ;</span><br><span class="line">func(a);  // 参数的值传递</span><br></pre></td></tr></table></figure><p>参数地址传递：函数在调用的时候实参传递的是一个数据的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void func1( int *p )  // 该函数的形参是一个指针</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;*p:%d\n&quot; , *p );</span><br><span class="line">    *p += 500 ;</span><br><span class="line">    printf(&quot;*p:%d\n&quot; , *p );</span><br><span class="line"></span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//////主函数的代码片段//////</span><br><span class="line">int a = 123 ;</span><br><span class="line">func1(&amp;a); // 调用函数func1的时候传递的是 a 地址</span><br></pre></td></tr></table></figure><p>数组作为形参：</p><p>数组在形参中出现时，该数组会被退化成一个指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expected ‘int *’ but argument is of type ‘int (*)[5]’  </span><br><span class="line">  28 | void func3( int arr [5] , int Len )  // 编译器善意提醒，形参中的  int arr [5] 实际上一个 ‘int *’</span><br></pre></td></tr></table></figure><p>【拓展】函数示例2：</p><ol><li><p>参数输入两个浮点数</p></li><li><p>函数内把交换两个浮点数</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Swap( float * f1 , float * f2 )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    float tmp = *f1 ;</span><br><span class="line"></span><br><span class="line">    *f1 = *f2  ;</span><br><span class="line">    *f2 = tmp ; </span><br><span class="line"></span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a><strong>函数指针：</strong></h4><p>概念： 这是一个指针，该指针指向的数据类型是一个函数的类型 （该指针变量中存储的是一个函数的入口地址）</p><p>语法：   函数的返回值类型 （*p） （ 函数的参数列表 ） ；</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">double func( int a , char * b , float f )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double d = a + *b + f ;</span><br><span class="line"></span><br><span class="line">    return  d ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 定义了一个函数指针 , 该指针直指向的类型是 double   ( int a , char * b , float f )</span><br><span class="line">    double (*p)( int a , char * b , float f ); </span><br><span class="line">    double (*p1)( int , char * , float );  // 一般在定义函数指针时，参数列表中的变量名会省略掉</span><br><span class="line">    p = func ; // 对 函数指针进行赋值 (把函数func 的入口地址写入到指针变量 p 中)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char c = &#x27;V&#x27;;</span><br><span class="line">    </span><br><span class="line">    // 使用函数名来调用该函数</span><br><span class="line">    double d = func( 123 , &amp;c , 345.123  );</span><br><span class="line">    printf(&quot;d:%lf\n&quot; , d );</span><br><span class="line"></span><br><span class="line">    // 如何通过指针p来访问函数</span><br><span class="line">    double d1 = p( 123 , &amp;c , 345.123  );</span><br><span class="line">    printf(&quot;d1:%lf\n&quot; , d1 );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指针函数："><a href="#指针函数：" class="headerlink" title="指针函数："></a><strong>指针函数：</strong></h4><p>概念： 这是一个函数，该函数的返回值是一个指针</p><p>语法： 类型 * 函数名 （ 参数列表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int * MemInit(int Len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int * p = malloc(Len);</span><br><span class="line">    if (p == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;malloc error&quot;);</span><br><span class="line">        return NULL ;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;malloc succeed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        假设这里是对内存的初始化操作</span><br><span class="line">        ........</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    return p ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组指针函数："><a href="#数组指针函数：" class="headerlink" title="数组指针函数："></a><strong>数组指针函数：</strong></h4><p>概念：这是一个函数，该函数的返回值是一个数组类型的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef     int (* RetTyp) [5] ; // 给类型 int (*) [5] 取了一个别名叫 RetTyp</span><br><span class="line"></span><br><span class="line">RetTyp MemInit( void )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 申请一个堆空间的数组</span><br><span class="line">    int (* p) [5] ;</span><br><span class="line">    p = calloc( 5 , sizeof (int) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return p ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针数组："><a href="#函数指针数组：" class="headerlink" title="函数指针数组："></a><strong>函数指针数组：</strong></h4><p>概念： 他是一个数组， 该数组中存放的是 指针 ， 这些指针指向的是 函数的入口地址</p><p>语法：  函数的返回值类型 * (数组名[5]) ( 参数列表 ) </p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int func1( float f )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;我是函数1 ,f的值:%f\n&quot;  , f );</span><br><span class="line">    </span><br><span class="line">    return 1 ;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">.......</span><br><span class="line">.........</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 定义了一个数组arr, 该数组有5个元素, 每一个元素都是函数类型地址   </span><br><span class="line">    int  (* arr[5]) ( float )  = &#123; </span><br><span class="line">            func1 , </span><br><span class="line">            func2 , </span><br><span class="line">            func3 , </span><br><span class="line">            func4 , </span><br><span class="line">            func5 </span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // arr[0] = func1 </span><br><span class="line">        int ret_val = arr[i] ( 123.456+i ) ;</span><br><span class="line">        printf(&quot;调用arr[%d],他的返回值:%d\n&quot; , i , ret_val);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用的流程"><a href="#函数调用的流程" class="headerlink" title="函数调用的流程"></a><strong>函数调用的流程</strong></h4><p>函数调用时，进程的上下文会切换到被调函数，当被调函数执行完毕之后再切换回去。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240225225416564.png" alt="image-20240225225416564"></p><h4 id="局部变量与栈内存"><a href="#局部变量与栈内存" class="headerlink" title="局部变量与栈内存"></a><strong>局部变量与栈内存</strong></h4><ul><li><p>局部变量概念：凡是被一对花括号包含的变量，称为局部变量</p></li><li><p>局部变量特点：</p><ul><li><p>某一函数内部的局部变量，存储在该函数特定的栈内存中</p></li><li><p>局部变量只能在该函数内可见（作用域），在该函数外部不可见</p></li><li><p>当该函数退出后，局部变量所占的内存立即被系统回收，因此局部变量也称为临时变量（不要把局部变量的地址进行返回）</p></li><li><p>函数的形参虽然不被花括号所包含，但依然属于该函数的局部变量</p></li></ul></li><li><p>栈内存特点：</p><ul><li><p>每当一个函数被调用时，系统将自动分配一段栈内存给该函数，用于存放其局部变量</p></li><li><p>每当一个函数退出时，系统将自动回收其栈内存</p></li><li><p>系统为函数分配栈内存时，遵循从上（高地址）往下（低地址）分配的原则</p></li></ul></li><li><p>技术要点：</p><ul><li><p>栈内存相对而言是比较小的，不适合用来分配尺寸太大的变量。</p></li><li><p>return 之后不可再访问函数的局部变量，因此返回一个局部变量的地址通常是错误的。</p></li></ul></li></ul><h4 id="static修饰的局部变量"><a href="#static修饰的局部变量" class="headerlink" title="static修饰的局部变量"></a><strong>static修饰的局部变量</strong></h4><p>概念: 当使用static 修改局部变量时， 是的该局部变量的存储空间从栈空间转移到数据段中（静态数据）</p><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0 ;</span><br><span class="line">    </span><br><span class="line">    // 使用 static修饰的 变量b  是的它成为一个静态数据， 它的存储期与程序保持一致，不会因为函数退出而回收</span><br><span class="line">    // 因此存储在静态变量b 中的数据是不会消失的</span><br><span class="line">    // 下一行初始化的语句只会被执行 一次 </span><br><span class="line">    static int b = 0 ;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a:%d b:%d\n&quot; , a++ , b++ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十一）进程的内存布局</title>
      <link href="/2024/02/24/11.%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2024/02/24/11.%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h2><h4 id="C进程内存布局"><a href="#C进程内存布局" class="headerlink" title="C进程内存布局"></a><strong>C进程内存布局</strong></h4><p>​任何一个程序，正常运行都需要内存资源，用来存放诸如变量、常量、函数代码等等。这些不同的内容，所存储的内存区域是不同的，且不同的区域有不同的特性。因此我们需要研究才能清楚内存布局，逐个了解不同内存区域的特性。</p><p>​每个C语言进程都拥有一片结构相同的虚拟内存，所谓的虚拟内存，就是从实际物理内存映射出来的地址规范范围，最重要的特征是所有的虚拟内存布局都是相同的，极大地方便内核管理不同的进程。<strong>例如三个完全不相干的进程p1、p2、p3，它们很显然会占据不同区段的物理内存，但经过系统的变换和映射，它们的虚拟内存的布局是完全一样的。</strong></p><ul><li>PM：Physical Memory，物理内存。</li><li>VM：Virtual Memory，虚拟内存。</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161328731.png" alt="image-20240223161328731">   </p><p>将其中一个C语言含有进程的虚拟内存放大来看，会发现其内部包下区域：</p><ul><li>栈（stack）</li><li>堆（heap）</li><li>数据段</li><li>代码段</li></ul><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240223161328731-17087879641635.png" alt="image-20240223161328731"></p><p>虚拟内存中，内核区段对于应用程序而言是禁闭的，它们用于存放操作系统的关键性代码，另外由于 Linux 系统的历史性原因，在虚拟内存的最底端 0x0 ~ 0x08048000 之间也有一段禁闭的区段，该区段也是不可访问的。</p><p>虚拟内存中各个区段的详细内容:</p><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240223161338105.png" alt="image-20240223161338105"></p><h4 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a><strong>栈内存</strong></h4><ul><li><p>什么东西存储在栈内存中？</p></li><li><ul><li><p>环境变量</p></li><li><p>命令行参数 （.&#x2F;a.out  123 Hello Even … ）</p></li><li><p>局部变量（包括形参）</p></li><li><ul><li>定义在函数体内{  }的变量成为局部变量，反之则成为全局变量</li><li>形参则是在函数头中的参数列表内定义的变量 成为<strong>形参</strong>   int main(**int argc, char const *argv[]**)</li></ul></li></ul></li><li><p>栈内存有什么特点？</p></li><li><ul><li>空间有限，尤其在嵌入式环境下（STM32 &#x2F; 51…）。因此不可以用来存储尺寸太大的变量。(如果超出范围则会出现栈溢出程序崩溃)</li><li>每当一个函数被调用，栈就会向下增长一段（被分配），用以存储该函数的局部变量。</li><li>每当一个函数退出，栈就会向上缩减一段（被回收），将该函数的局部变量所占内存归还给系统。</li></ul></li></ul><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240223161402580.png" alt="image-20240223161402580"></p><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240223161354680.png" alt="image-20240223161354680"></p><p>栈内存的分配和释放，都是由系统规定的，我们无法干预。</p><h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a><strong>局部作用域</strong></h4><ul><li>概念：在代码块中定义的变量(局部变量)，其可见范围从其定义处开始，到代码块结束为止。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;  // 主函数的作用域</span><br><span class="line">    // a = 123 ; // [错误] 需要在定义语句后，才能正确访问变量</span><br><span class="line">    int a=1;   // a的作用域从该语句运行结束后开</span><br><span class="line">    int b=2;     // 变量 c 的作用域是第4行到第9行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;LINE:%d\ta:%d\n&quot; , __LINE__ ,a );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; // 👇👇👇👇👇👇新的作用域的开始👇👇👇👇👇👇</span><br><span class="line">        int c=4;</span><br><span class="line">        int d=5; // 变量 d 的作用域是第7行到第8行</span><br><span class="line"></span><br><span class="line">        printf(&quot;LINE:%d\ta:%d\n&quot; , __LINE__ ,a );</span><br><span class="line">        printf(&quot;LINE:%d\tc:%d\n&quot; , __LINE__ ,c );</span><br><span class="line">        </span><br><span class="line">        // 这里又定义了一个a 但是当前的a 属于一个小范围的作用域,</span><br><span class="line">        // 在该作用域的a 会临时掩盖大作用域中同名的变量</span><br><span class="line">        int a = 100; </span><br><span class="line">        printf(&quot;LINE:%d\ta:%d\n&quot; , __LINE__ ,a );</span><br><span class="line">    &#125;// 👆👆👆👆👆新的作用域的结束👆👆👆👆👆👆👆👆</span><br><span class="line"></span><br><span class="line">    // 当我们离开小作用域后,该作用域中所有的变量都会被释放 (交给系统重新分配)</span><br><span class="line">    // printf(&quot;LINE:%d\tc:%d\n&quot; , __LINE__ ,c ); // [编译保存] 未定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;LINE:%d\ta:%d\n&quot; , __LINE__ ,a );</span><br><span class="line">&#125; // 直到该 大括号 &#125;  表示结束</span><br></pre></td></tr></table></figure><ul><li><p>要点：</p></li><li><ul><li>代码块指的是一对花括号 { } 括起来的区域。</li><li>代码块可以嵌套包含，外层的标识符（变量名…）会被内嵌的同名标识符临时掩盖变得不可见。</li><li>代码块作用域的变量，由于其可见范围是局部的，因此被称为局部变量。</li></ul></li><li><p><strong>自动</strong>存储期</p></li></ul><p>在栈内存中分配的变量，统统拥有自动存储期，因此也都被称为自动变量。这里自动的含义，指的是这些变量的内存管理不需要开发者操心，都是全自动的：在变量定义处自动分配，出了变量的作用域后自动释放。</p><ul><li><p>以下三个概念是等价的：</p></li><li><ul><li>自动变量：从存储期的角度，描述变量的时间特性。</li><li>临时变量：同上。</li><li>局部变量：从作用域（作用访问是局部 { 只能在代码块内部使用 }）的角度，描述变量的空间特性。</li></ul></li><li><p>注意：</p></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161420082.png" alt="image-20240223161420082"></p><p><strong>数据段与代码段</strong></p><ul><li><p>数据段细分成如下几个区域：</p></li><li><ul><li>.bss（Block Started by Symbol） 段：存放未初始化的静态数据，它们将被系统自动初始化为0</li><li>.data段：存放已初始化的静态数据</li><li>.rodata段：存放常量数据 （该区域的所有数据都是不允许被修改的）</li></ul></li><li><p>代码段细分成如下几个区域：</p></li><li><ul><li>.text段：存放用户代码</li><li>.init段：存放系统初始化代码（编译器根据实际的目标系统自动添加）</li></ul></li></ul><p> <img src="/imgs/$%7Bfiilename%7D/image-20240223161430893.png" alt="image-20240223161430893"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a;       // 未初始化的全局变量，放置在.bss 中</span><br><span class="line">int b = 100; // 已初始化的全局变量，放置在.data 中</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    static int c;       // 未初始化的静态局部变量，放置在.bss 中</span><br><span class="line">    static int d = 200; // 已初始化的静态局部变量，放置在.data 中</span><br><span class="line">    </span><br><span class="line">    // 以上代码中的常量100、200防止在.rodata 中</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注意：数据段和代码段内存的分配和释放，都是由系统规定的，我们无法干预。</li></ul><h4 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a><strong>静态数据</strong></h4><p>概念： 数据的生存周期是固定， 不会因为程序执行某些操作而申请或释放它所占用的内存。</p><p>他们的内存是在程序运行之处就被申请出来， 直到程序运行结束才会释放回收。</p><p>C语言中，静态数据有两种：</p><ul><li>全局变量：定义在函数外部的变量。</li><li>静态局部变量：定义在函数内部，且被static修饰的变量。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a; // 全局变量，退出整个程序之前不会释放</span><br><span class="line">void f(void)</span><br><span class="line">&#123;</span><br><span class="line">    static int b; // 静态局部变量，退出整个程序之前不会释放</span><br><span class="line">    printf(&quot;%d\n&quot;, b);</span><br><span class="line">    b++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    f(); // 重复调用函数 f()，会使静态局部变量 b 的值不断增大</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>为什么需要静态数据？</p></li><li><ol><li>全局变量在默认的情况下，对所有文件可见，为某些需要在各个不同文件和函数间访问的数据提供操作上的方便。</li><li>当我们希望一个函数退出后依然能保留局部变量的值，以便于下次调用时还能用时，静态局部变量可帮助实现这样的功能。</li></ol></li><li><p>注意1：</p></li><li><ul><li>若定义静态数据 （ 全局变量 、 被static修饰的局部变量 ） 时未初始化，则系统会将所有的静态数据自动初始化为0</li><li>静态数据初始化语句，只会执行一遍。</li><li>静态数据从程序开始运行时便已存在，直到程序退出时才释放。</li></ul></li><li><p>注意2 static关键字的作用：</p></li><li><ul><li>static修饰局部变量：使之由栈内存临时数据，变成了静态数据。</li><li>static修饰全局变量：使之由各文件可见的静态数据，变成了本文件可见的静态数据。</li><li>static修饰函数：使之由各文件可见的函数，变成了本文件可见的静态函数。</li></ul></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 全局变量定义</span><br><span class="line">int Num1 = 456 ;   // 该变量Num 的可见范围(作用域)是整个程序(可能由多个.c文件组成)可见</span><br><span class="line">                    // 如果在其他文件也定义一样全局变量,那么将会发成重定义的冲突问题</span><br><span class="line">                    // 不利于模块化编程</span><br><span class="line"></span><br><span class="line">static int Num2 = 567 ; // 使用static 修饰的全局变量,他的作用域(可见范围)仅本文件可见</span><br><span class="line">                    // 如果在其他文件也定义一样全局变量,那么将不会发生重定义的冲突问题 </span><br><span class="line">                    // 有利于模块化编程</span><br><span class="line">                    // 如果其他文件确实需要使用到该变量,</span><br><span class="line">                    // 那么一般就会把该变量定义的语句写入到头文件中,需要用到的文件直接包含头文件即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int a = 123 ; // 该变量a 属于函数main的局部变量</span><br><span class="line">                // 当该函数被执行的时候 自动分配出来 它所在区域为 栈空间</span><br><span class="line">                // 当函数运行结束时会被系统自动回收</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static int b = 456 ; // 该变量是在程序被执行的时候直接分配</span><br><span class="line">                        // 该变量的存储区域 是 数据段 的.data段</span><br><span class="line">                        // 他的生命周期与程序保持一致 , 不会因为函数运行结束而释放</span><br><span class="line">                        //  (只要程序没有退出,他的值可以一直延用)</span><br><span class="line">                        // 该数据为静态数据,因此无法手动对他进行释放</span><br><span class="line">                        </span><br><span class="line">    char * p = &quot;Hello Even\n&quot; ; // 指针 p 是一个局部变量.他的存储区在栈空间</span><br><span class="line">                            // 它指向了 数据段中 .rodata 中&quot;Hello Even\n&quot; 的入口地址</span><br><span class="line"></span><br><span class="line">    static char * p1 = &quot;Hello Even\n&quot; ; // 指针 p1 是一个静态的局部变量, 它的存储区在 数据段的 .data 段</span><br><span class="line">                    // 它指向了 数据段中 .rodata 中&quot;Hello Even\n&quot; 的入口地址</span><br><span class="line">                    // p 会因为函数的运行结束而释放, p1 则不会, 他的生命周期与程序保持一致</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作练习：</p><p>尝试使用画图工具把以上示例代码中各个变量在内存中进行标记。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161602382.png" alt="image-20240223161602382"></p><h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a><strong>堆内存</strong></h4><p>堆内存（heap）又被称为动态内存、自由内存，简称堆。堆是唯一可被开发者自定义的区段，开发者可以根据需要申请内存的大小、决定使用的时间长短等。但又由于这是一块系统“飞地”，所有的细节均由开发者自己把握，系统不对此做任何干预，给予开发者绝对的“自由”，但也正因如此，对开发者的内存管理提出了很高的要求。对堆内存的合理使用，几乎是软件开发中的一个永恒的话题。</p><ul><li><p>堆内存基本特征：</p></li><li><ul><li>相比栈内存，堆的总大小仅受限于物理内存，在物理内存允许的范围内，系统对堆内存的申请不做限制。</li><li>相比栈内存，堆内存从下往上增长。</li><li>堆内存是匿名的，只能由指针来访问。</li><li>自定义分配的堆内存，除非开发者主动释放，否则永不释放，直到程序退出。</li></ul><p> <img src="/imgs/$%7Bfiilename%7D/image-20240223161632962.png" alt="image-20240223161632962"></p></li><li><p>相关API：</p></li><li><ul><li>申请堆内存：malloc ( ) &#x2F; calloc ( )</li><li>清零堆内存：bzero ( )</li><li>释放堆内存：free ( )</li><li>重新申请 realloc ( )</li></ul></li></ul><p>分析堆内存的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">申请堆内存空间，并返回该内存的入口地址， 但是不会对该内存进行初始化操作。</span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">函数原型：</span><br><span class="line">    void *malloc(size_t size);</span><br><span class="line">参数分析：</span><br><span class="line">    size --&gt; 需要申请的内存的大小（字节） </span><br><span class="line">返回值：</span><br><span class="line">    成功 返回一个已经分配好的内存</span><br><span class="line">    失败 返回 NULL </span><br><span class="line">                                   </span><br><span class="line">释放内存空间：       </span><br><span class="line">函数原型：                             </span><br><span class="line">    void free(void *ptr);</span><br><span class="line">参数分析：</span><br><span class="line">    ptr --&gt; 需要释放的堆内存的入口地址 （必须是堆内存+入口地址）</span><br><span class="line">返回值：</span><br><span class="line">    成功  无</span><br><span class="line">    失败  无</span><br><span class="line">    </span><br><span class="line">函数原型(更适用于数组的申请)并对申请得到的内存进行初始化为 0 ：           </span><br><span class="line">    void *calloc(size_t nmemb, size_t size);</span><br><span class="line">参数分析：</span><br><span class="line">    nmemb --&gt; 数组元素的个数</span><br><span class="line">    size --&gt; 每一个元素的大小    </span><br><span class="line">返回值：</span><br><span class="line">    成功 返回申请到的内存入口地址</span><br><span class="line">    失败 返回 NULL </span><br><span class="line">    </span><br><span class="line">函数原型：           </span><br><span class="line">    void *realloc(void *ptr, size_t size);</span><br><span class="line">参数分析：</span><br><span class="line">    ptr --&gt; 旧的堆空间入口地址</span><br><span class="line">    size --&gt; 新空间的内存大小</span><br><span class="line">返回值：  </span><br><span class="line">    成功 返回新的入口地址 （如果没有换到新的内存下则返回值与参数ptr相同）</span><br><span class="line">    失败 返回null </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">void *reallocarray(void *ptr, size_t nmemb, size_t size);</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161700746.png" alt="image-20240223161700746"></p><ul><li><p>注意：</p></li><li><ul><li>malloc()申请的堆内存，默认情况下是随机值，一般需要用 bzero() 来清零(拓展)。</li><li>calloc()申请的堆内存，默认情况下是已经清零了的，不需要再清零。</li><li>free()只能释放堆内存，并且只能释放整块堆内存（必须是某一块堆空间的入口地址），不能释放别的区段的内存或者释放一部分堆内存。</li></ul></li><li><p>释放内存的含义：</p></li><li><ul><li>释放内存意味着将内存的使用权归还给系统。</li><li>释放内存并不会改变指针的指向（会出现野指针）。</li><li>释放内存并不会对内存做任何修改，更不会将内存清零（所以内存中会有随机值）。</li></ul></li></ul><p>作业练习：</p><ul><li>把今天所学的内容自己过一下解决未能理解的点</li><li>尝试自己画一下 内存布局图，过程中回顾一下各个区域的特点</li></ul><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240223161713711.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "></p><ul><li>编写代码验证一下内存布局（地址大小关系）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 全局变量 （静态数据）</span><br><span class="line">int a ;   // a 是静态数据， 没有初始化因此它的存储区域在 .bss  默认初始值为 0 </span><br><span class="line">int b = 333 ; // b 是静态数据，有进行初始化因此它存储的区域在  .data </span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;argv[0]:%p\n&quot; , argv[0]); // 命令行参数</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;argc的地址:%p\n&quot; , &amp;argc);  // 在参数列表中定义的变量属于该函数的局部变量</span><br><span class="line"></span><br><span class="line">    int Num = 123 ;</span><br><span class="line">    printf(&quot;&amp;Num的地址:%p\n&quot; , &amp;Num);  // 在函数体内部定义，因此它属于该函数的局部变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 在堆内存中申请了10个字节的内存空间并把该内存的入口地址 存入到 msg 指针变量中</span><br><span class="line">    char * msg = calloc(10 , sizeof(char) ) ; </span><br><span class="line">    printf(&quot;msg:%p\n&quot; , msg); </span><br><span class="line"></span><br><span class="line">    // 数据段的内存</span><br><span class="line">    printf(&quot;a的地址:%p\n&quot; , &amp;a); </span><br><span class="line">    printf(&quot;b的地址:%p\n&quot; , &amp;b); </span><br><span class="line"></span><br><span class="line">    // 使用指针p 指向了常量区的 &quot;Hello Even&quot; 的入口地址</span><br><span class="line">    char * p = &quot;Hello Even&quot; ;</span><br><span class="line"></span><br><span class="line">    printf(&quot;p:%p\n&quot; , p); </span><br><span class="line">    </span><br><span class="line">    // 代码段</span><br><span class="line">    printf(&quot;main 主函数的入口地址：%p\n&quot; , main);</span><br><span class="line">    printf(&quot;&amp;main 主函数的入口地址：%p\n&quot; , &amp;main);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十）指针与数组的理解</title>
      <link href="/2024/02/24/10.%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/24/10.%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="指针与数组的理解"><a href="#指针与数组的理解" class="headerlink" title="指针与数组的理解"></a>指针与数组的理解</h2><p><strong>代码1：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223160910291.png" alt="image-20240223160910291"></p><p><strong>代码2：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223160927552.png" alt="image-20240223160927552"></p><p><strong>代码3：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223160945595.png" alt="image-20240223160945595"></p><p><strong>代码4：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161056531.png" alt="image-20240223161056531"></p><p><strong>代码5：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161114539.png" alt="image-20240223161114539"></p><p><strong>代码6：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161132253.png" alt="image-20240223161132253"></p><p><strong>代码7：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161148072.png" alt="image-20240223161148072"></p><p><strong>代码8：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161212566.png" alt="image-20240223161212566"></p><p><strong>代码9：</strong></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240223161230446.png" alt="image-20240223161230446"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（九）指针的深入理解</title>
      <link href="/2024/02/24/9.%E6%8C%87%E9%92%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/24/9.%E6%8C%87%E9%92%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="指针的深入理解"><a href="#指针的深入理解" class="headerlink" title="指针的深入理解"></a>指针的深入理解</h2><h4 id="char型指针"><a href="#char型指针" class="headerlink" title="char型指针"></a><strong>char型指针</strong></h4><p>char型指针实质上跟别的类型的指针并无本质区别，但由于C语言中的字符串以字符数组的方式存储，而数组在大多数场合又会表现为指针，因此字符串在绝大多数场合就表现为char型指针。</p><ul><li>定义：</li></ul><p>char *p &#x3D; “abcd”; &#x2F;&#x2F; 指针p指向了常量区中的数据”abcd”   不允许该该数据的任何内容</p><h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a><strong>多级指针</strong></h4><ul><li>如果一个指针变量 p1 存储的地址，是另一个普通变量 a 的地址，那么称 p1 为一级指针</li><li>如果一个指针变量 p2 存储的地址，是指针变量 p1 的地址，那么称 p2 为二级指针</li><li>如果一个指针变量 p3 存储的地址，是指针变量 p2 的地址，那么称 p3 为三级指针</li><li>以此类推，p2、p3等指针被称为多级指针</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line"></span><br><span class="line">int * p1  = &amp;a ; // p1 中存放了变量 a 的地址            一级指针</span><br><span class="line">int **p2  = &amp;p1; // p2 中存放了 指针变量 p1 的地址      二级指针</span><br><span class="line">int ***p3 = &amp;p2; // p3 中存放了 一个二级指针p2的地址    三级指针</span><br><span class="line"></span><br><span class="line">printf(&quot;&amp;a:%p \ta:%d\n&quot; , &amp;a , a );</span><br><span class="line">printf(&quot;&amp;p1:%p \tp1:%p\n&quot; , &amp;p1 , p1 );</span><br><span class="line">printf(&quot;&amp;p2:%p \tp2:%p\n&quot; , &amp;p2 , p2 );</span><br><span class="line">printf(&quot;&amp;p3:%p \tp3:%p\n&quot; , &amp;p3 , p3 );</span><br><span class="line"></span><br><span class="line">如何访问数据：</span><br><span class="line">printf(&quot;a:%d\n&quot; , a );</span><br><span class="line">printf(&quot;*p1:%d\n&quot; , *p1 ); // p1 = &amp;a --&gt;  *p1 = *&amp;a --&gt;  *p1 = a  &amp;取地址  *解引用</span><br><span class="line">printf(&quot;**p2:%d\n&quot; , **p2 ); // p2 = &amp;p1 -&gt; *p2 = *&amp;p1 -&gt; *p2 = p1  -&gt; *p1 = **p2</span><br><span class="line">printf(&quot;***p3:%d\n&quot; , ***p3 );  //  p3 = &amp;p2 -&gt; *p3 = *&amp;p2  -&gt; *p3 = p2</span><br></pre></td></tr></table></figure><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240222195938624.png" alt="image-20240222195938624"></p><h4 id="指针万能拆解法"><a href="#指针万能拆解法" class="headerlink" title="指针万能拆解法"></a><strong>指针万能拆解法</strong></h4><ul><li><p>任意的指针，不管有多复杂，其定义都由两部分组成。</p></li><li><ul><li>第1部分：指针所指向的数据类型，可以是任意的类型</li><li>第2部分：指针的名字以及明确他是一个指针*</li></ul></li></ul><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240222200001701-17087600122002.png" alt="image-20240222200001701"></p><ul><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char   (*p1);      // 第2部分：*p1; 第1部分：char; </span><br><span class="line">char  *(*p2);      // 第2部分：*p2; 第1部分：char *; </span><br><span class="line">char **(*p3);      // 第2部分：*p3; 第1部分：char **; </span><br><span class="line">char   (*p4)[3];  // 第2部分：*p4; 第1部分：char [3]; </span><br><span class="line">char   (*p5)(int, float); // 第2部分：*p5; 第1部分：char (int, float); </span><br><span class="line">char   (*p1);      // 第2部分：*p1; 第1部分：char;  </span><br><span class="line">char  *(*p2);      // 第2部分：*p2; 第1部分：char *;  </span><br><span class="line">char **(*p3);      // 第2部分：*p3; 第1部分：char **;  </span><br><span class="line">char   (*p4)[3];  // 第2部分：*p4; 第1部分：char [3];  </span><br><span class="line">char   (*p5)(int, float); // 第2部分：*p5; 第1部分：char (int, float); </span><br></pre></td></tr></table></figure><ul><li>注解：</li></ul><ol><li>上述示例中，p1、p2、p3、p4、p5本质上并无区别，它们均是指针</li><li>上述示例中，p1、p2、p3、p4、p5唯一的不同，是它们所指向的数据类型不同</li><li>第1部分的声明语句，如果由多个单词组成，C语言规定需要将其拆散写到第2部分的两边</li></ol><h4 id="void型指针"><a href="#void型指针" class="headerlink" title="void型指针"></a><strong>void型指针</strong></h4><ul><li><p>概念：无法明确指针所指向的数据类型时，可以将指针定义为 void 型指针</p></li><li><p>要点：</p></li><li><ol><li>void 型指针无法直接索引目标，必须将其转换为一种具体类型的指针方可索引目标</li><li>void 型指针无法进行加减法运算 （有点奇怪实际能进行一个字节的加减运算）</li></ol></li></ul><p>参考：</p><p><img src="C:\Users\xuehui\Desktop\嵌入式笔记\C语言基础\assets\image-20240223153855410.png" alt="image-20240223153855410"></p><p>建议不要随便直接对void 指针进行加减运算（对编译器及其版本有所限制）。</p><ul><li><p>void关键字的三个作用：</p></li><li><ol><li>修饰指针，表示指针指向一个类型未知类型的数据。</li><li>修饰函数参数列表，表示函数不接收任何参数。（预习）int main(void)</li><li>修饰函数返回类型，表示函数不返回任何数据。（预习）void func(int)</li></ol></li><li><p>示例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 指针 p 指向一块 4 字节的内存，且这4字节数据类型未确定</span><br><span class="line">void *p = malloc(4);</span><br><span class="line"></span><br><span class="line">// 1，将这 4 字节内存用来存储 int 型数据</span><br><span class="line">*(int *)p = 100;</span><br><span class="line">printf(&quot;%d\n&quot;, *(int *)p);</span><br><span class="line"></span><br><span class="line">// 2，将这 4 字节内存用来存储 float 型数据</span><br><span class="line">*(float *)p = 3.14;</span><br><span class="line">printf(&quot;%f\n&quot;, *(float *)p);</span><br></pre></td></tr></table></figure><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a><strong>const关键字</strong></h4><p>作用：修饰变量，使一个变量不可修改（常量）</p><ul><li><ul><li>修饰普通变量，使之不可修改</li><li>修饰指针变量，使之不可修改或者使其指向的目标不可修改</li></ul></li></ul><h4 id="const-型变量"><a href="#const-型变量" class="headerlink" title="const 型变量"></a><strong>const 型变量</strong></h4><p>语法： const 变量类型   变量名  &#x3D; 初始值 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line">    </span><br><span class="line">// 修饰普通变量，使得该变量的值不可修改</span><br><span class="line">const int b = 456 ;  // 被const 修饰的变量除了初始化时能对他赋值意外</span><br><span class="line">                    // 其他的情况下无法对它进行赋值</span><br><span class="line"></span><br><span class="line">printf(&quot;a:%d \t b:%d\n&quot; , a , b);</span><br><span class="line"></span><br><span class="line">a = 543 ; // [正确]</span><br><span class="line">// b = 321 ; // [错误] error: assignment of read-only variable ‘b’</span><br></pre></td></tr></table></figure><h4 id="const-型指针"><a href="#const-型指针" class="headerlink" title="const 型指针"></a><strong>const 型指针</strong></h4><p><strong>常（量）指针：</strong> </p><p>修饰的是指针本身， 该指针为一个常量。</p><p>语法：  数据类型 * const  指针名 &#x3D;  指向的地址 ；</p><p>操作示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line">printf(&quot;LINE:%d a:%d \n&quot; , __LINE__ , a );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int * p = &amp;a ;</span><br><span class="line"></span><br><span class="line">int * const p1 = &amp;a ;</span><br><span class="line"></span><br><span class="line">*p = 456 ; // 通过指针 p 来修改变量 a 中的数据</span><br><span class="line">printf(&quot;LINE:%d a:%d \n&quot; , __LINE__ , a );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*p1 = 789 ; // 通过指针 p1 来修改变量 a 中的数据</span><br><span class="line">printf(&quot;LINE:%d a:%d \n&quot; , __LINE__ , a );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int b = 999 ;</span><br><span class="line">p = &amp;b ; // 修改指针p的指向 (把b的地址存入指针变量 p 中)</span><br><span class="line">printf(&quot;LINE:%d *p:%d \n&quot; , __LINE__ , *p );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// p1 定义的时候被修饰成了一个常量指针 (该指针是一个常量)</span><br><span class="line">// 因此 无法修改该常量指针的值 (无法改变指向)</span><br><span class="line">p1 = &amp;b ; // [错误] 修改指针p1的指向 (把b的地址存入指针变量 p1 中)</span><br></pre></td></tr></table></figure><h4 id="常（量）目标指针："><a href="#常（量）目标指针：" class="headerlink" title="常（量）目标指针："></a><strong>常（量）目标指针：</strong></h4><p>修饰的是指针所指向目标类型， 指针所指向的目标是一个常量。</p><p>语法： </p><ul><li><p>const  类型   * 指针名 &#x3D; 指向的地址 ；</p></li><li><p>类型 const  * 指针名 &#x3D; 指向的地址 ；</p></li></ul><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// argv[0][1] = &#x27;k&#x27;; // [错误] 数组argv中的类型为 char const 类型,不允许被修改</span><br><span class="line">                // argv 数组中存放的 是常目标指针 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a = 123 ;</span><br><span class="line">printf(&quot;LINE:%d:%d\n&quot; ,__LINE__ ,  a );</span><br><span class="line"></span><br><span class="line">int * p1 = &amp;a ;</span><br><span class="line"></span><br><span class="line">const int * p2 = &amp;a ;</span><br><span class="line">int const * p3 = &amp;a ;</span><br><span class="line"></span><br><span class="line">*p1 = 345 ; // 把345的二进制编码存入到 p1 所指向的内存中 (修改内存中的值)</span><br><span class="line">printf(&quot;LINE:%d:%d\n&quot; ,__LINE__ ,  a );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// error: assignment of read-only location ‘*p2’</span><br><span class="line">// *p2 = 567 ;  // [错误]  p2 所指向的是一个常量的数据 不允许被修改</span><br><span class="line">a = 888 ;  // [正确] 变量自身是可以被改变的只是不允许通过 p2 来改变 a 的值</span><br><span class="line"></span><br><span class="line">int b = 999 ;</span><br><span class="line">p1 = &amp;b ;  // 修改p1中的值(修改p1 指向)</span><br><span class="line">p2 = &amp;b; // [正确] 修改p2中的值(修改p2 指向)</span><br><span class="line"></span><br><span class="line">printf(&quot;*p2:%d\n&quot; , *p2);</span><br></pre></td></tr></table></figure><ul><li><p>常指针在实际应用中不常见。</p></li><li><p>常目标指针在实际应用中广泛可见，用来限制指针的读写权限(保护内存不会被误操作修改)</p></li></ul><p>操作练习：</p><p>自行编写代码体会一下常目标指针与常指针的区别。</p><h4 id="数组指针："><a href="#数组指针：" class="headerlink" title="数组指针："></a><strong>数组指针：</strong></h4><p>概念： 这是一个指针，用来指向一个数组的指针。</p><p>语法： 类型（*p）[元素个数] ；</p><p>操作示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int arr [5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// arr 与 &amp;arr  得到的值是同一个值, 都是代表某一个地址</span><br><span class="line">//  区别在于他的意义不一样 ,  arr 表示的是首元素的地址   &amp;arr 表示的是整个数组的地址</span><br><span class="line">int * p1 = arr ; // arr 代表首元素 1 的地址, p1 就指向了数据 1 的地址</span><br><span class="line">// int * p0 = &amp;arr ;  // [有警告] 数据的类型不匹配</span><br><span class="line"></span><br><span class="line">int (*p2) [5] = &amp;arr ; // &amp;arr 表示的是整个数组的地址, p2 指向了整个数组</span><br><span class="line">// int (*p3) [5] = arr ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数组指针加减运算</span><br><span class="line">int * p4 = p2+1 ; // p2是一个指针,它指向的类型 是 int [5] ,因此 +1 则+ int * 5 = 20 字节</span><br><span class="line"></span><br><span class="line">printf(&quot;arr:%p\n&quot; , arr );</span><br><span class="line">printf(&quot;p4:%p\n&quot; , p4); </span><br><span class="line"></span><br><span class="line">// 如何通过数组指针来访问数组中的每个数据</span><br><span class="line">printf( &quot;**p2:%d\n&quot; ,  **p2  ); </span><br><span class="line">// p2 = &amp;arr  -&gt; *p2 = *&amp;arr -&gt; *p2 = arr  -&gt; **p2 = *arr -&gt;*arr = arr[0] / *(arr+0)</span><br><span class="line"></span><br><span class="line">printf( &quot;*(*p2+1):%d\n&quot; ,  *(*p2+1)  );  // *p2 = arr -&gt;  *(arr+1) -&gt; arr[1]</span><br><span class="line"></span><br><span class="line">printf( &quot;(*p2)[2] :%d\n&quot; ,  (*p2)[2]  );  // (*p2) = arr </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（八）数组的深入理解</title>
      <link href="/2024/02/24/8.%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/24/8.%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的深入理解"><a href="#数组的深入理解" class="headerlink" title="数组的深入理解"></a>数组的深入理解</h2><h4 id="数组名含义"><a href="#数组名含义" class="headerlink" title="数组名含义"></a><strong>数组名含义</strong></h4><ul><li><p>数组名有两个含义：</p><ul><li><p>第一含义是：整个数组</p></li><li><p>第二含义是：首元素地址</p></li></ul></li><li><p>当出现以下情形时，那么数组名就代表整个数组：</p><ul><li><p>在数组定义中  int arr [3] ; arr 表示整个数组</p></li><li><p>在 sizeof 运算表达式中  sizeof(arr) ;  得到的结果是整个数组的占用内存   type * 元素个数</p></li><li><p>在取址符&amp;中  p &#x3D; <strong>&amp; arr</strong> ;  取得数组 arr  的地址， 因此  <strong>表示整个数组的地址</strong></p></li></ul></li><li><p>其他任何情形下，那么数组名就代表首元素地址。即：此时数组名就是一个指向首元素的指针。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int arr[5] = &#123;3,4,5,1,2&#125;;</span><br><span class="line">int *p = arr;          // 当前的arr不属于以上三种情况， 因此它代表 首元素的首地址  数据 3 的地址</span><br><span class="line">int (*p1)[5] = &amp;arr ;    // p1 是一个指针  它指向（存放的地址）的数据类型，是 int [5]的类型</span><br><span class="line">                  // &amp;arr 表示整个数组的地址                  </span><br><span class="line"></span><br><span class="line">int *p2 = arr+1 ;       // arr 是数组首元素的首地址 +1 则 + 一个元素的类型大小</span><br><span class="line">                  // 因此 arr+1 则+了一个整形大小，也就是 数据 4 的地址</span><br><span class="line">    </span><br><span class="line">printf(&quot;p:%d p1:%d p2:%d\n&quot; , *p , *p1[1] , *p2 );     //3,&#123;...&#125;,4</span><br><span class="line">int (*p3)[5] = &amp;arr + 1 ;  // &amp;arr 表示整个数组 arr 的地址</span><br><span class="line">                  // 整个数组的地址  + 1  则+一个数组的大小</span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a[3];               // 此处，a 代表整个数组 </span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(a));  // 此处，a 代表整个数组</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;a);        // 此处，a 代表整个数组，此处为整个数组的地址</span><br><span class="line"></span><br><span class="line">int *p = a;       // 此处，a 代表首元素 a[0] 的地址，等价于 &amp;a[0]</span><br><span class="line">p = a + 1;        // 此处，a 代表首元素 a[0] 的地址，等价于 &amp;a[0]</span><br><span class="line">function(a);      // 此处，a 代表首元素 a[0] 的地址，等价于 &amp;a[0]</span><br><span class="line">scanf(&quot;%d\n&quot;, a); // 此处，a 代表首元素 a[0] 的地址，等价于 &amp;a[0]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C语言只有在第一含义的场合下表现为数组，其他大部分场合都表现为首元素的地址，当数组表现为首元素地址时，实际上就是一个指向其首元素的指针。数组运算实际上就是指针运算。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240109214126882.png" alt="image-20240109214126882"></p><h4 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a><strong>数组下标</strong></h4><ul><li>数组下标实际上是编译系统的一种简写，其等价形式是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = 100;  等价于  *(a+i) = 100;</span><br></pre></td></tr></table></figure><ul><li>根据加法交换律，以下的所有的语句均是等价的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  a[i] = 100;</span><br><span class="line">*(a+i) = 100;</span><br><span class="line">*(i+a) = 100;</span><br><span class="line">  i[a] = 100; // 3[arr] = 123 ;</span><br><span class="line">          // arr[3] = 123 ;</span><br><span class="line"></span><br><span class="line">// 以下四个语句都能正确访问数据</span><br><span class="line">printf(&quot;arr[2]:%d\n&quot; , arr[2]) ;</span><br><span class="line">printf(&quot;*(arr+2):%d\n&quot; , *(arr+2)) ;</span><br><span class="line">printf(&quot;*(2+arr):%d\n&quot; , *(2+arr)) ;</span><br><span class="line">printf(&quot;2[arr]:%d\n&quot; , 2[arr]) ;</span><br></pre></td></tr></table></figure><ul><li>数组运算，等价于指针运算。</li></ul><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a><strong>字符串常量</strong></h4><ul><li>字符串常量在内存中的存储（存储在常量区-该区域不允许被修改（只读ReadOnly）），实质是一个匿名数组</li><li>匿名数组，同样满足数组两种涵义的规定</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;, sizeof(&quot;abcd&quot;)); // 此处 &quot;abcd&quot; 代表整个数组</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;&quot;abcd&quot;);        // 此处 &quot;abcd&quot; 代表整个数组</span><br><span class="line"></span><br><span class="line">printf(&quot;%c\n&quot;, &quot;abcd&quot;[1]); // 此处 &quot;abcd&quot; 代表匿名数组的首元素地址</span><br><span class="line">char *p1 = &quot;abcd&quot;;         // 此处 &quot;abcd&quot; 代表匿名数组的首元素地址</span><br><span class="line">char *p2 = &quot;abcd&quot; + 1;     // 此处 &quot;abcd&quot; 代表匿名数组的首元素地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109214213148.png" alt="image-20240109214213148"></p><p>字符串常量是以字符串数组的形式存储在数据段（常量区）。</p><h4 id="零长数组（预习：结构体）"><a href="#零长数组（预习：结构体）" class="headerlink" title="零长数组（预习：结构体）"></a><strong>零长数组（预习：结构体）</strong></h4><ul><li>概念：长度为0的数组，比如 int data[0];</li><li>用途：放在结构体的末尾，作为可变长度数据的入口</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    /* 结构体的其他成员 */</span><br><span class="line">    // 成员1</span><br><span class="line">    // 成员2</span><br><span class="line">    // ... ...</span><br><span class="line">    </span><br><span class="line">    int   len;</span><br><span class="line">    char *data[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 给结构体额外分配 10 个字节的内存。</span><br><span class="line">struct node *p = malloc(sizeof(struct node) + 10);</span><br><span class="line">p-&gt;len = 10;</span><br><span class="line"></span><br><span class="line">// 额外分配的内存可以通过 data 来使用</span><br><span class="line">p-&gt;data[0] ~ p-&gt;data[9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a><strong>变长数组</strong></h4><ul><li>概念：定义时，使用变量作为元素个数的数组（使用变量作为数组定义时的大小）。</li><li>要点：变长数组仅仅指元素个数在定义时是变量，而绝非指数组的长度可长可短。实际上，不管是普通数组还是所谓的变长数组，数组一旦定义完毕，其长度则不可改变。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int arr[60];</span><br><span class="line"></span><br><span class="line">int len = 5; // 可能通过某些运算，或用户的选择得到了数组的大小</span><br><span class="line">int a[len];  // 数组元素个数 len 是变量，因此数组 a 是变长数组</span><br><span class="line"></span><br><span class="line">len = 30 ; // 再次修改变量的值并不会影响数组的大小</span><br><span class="line"></span><br><span class="line">int x = 2;</span><br><span class="line">int y = 3;</span><br><span class="line">int b[x][y]; // 数组元素个数 x、y 是变量，因此数组 b 是变长数组</span><br><span class="line">int b[2][y]; // 数组元素个数 y 是变量，因此数组 b 是变长数组</span><br><span class="line">int b[x][3]; // 数组元素个数 x 是变量，因此数组 b 是变长数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>语法：<strong>变长数组不可初始化</strong>，即以下代码是错误的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int len = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a[len] = &#123;1,2,3,4,5&#125;; // 数组 a 不可初始化 ， 应在再定义数组之前该数组的大小都是未知的，因此无法进行初始化</span><br><span class="line">// 编译器报错：</span><br><span class="line">variable-sized object may not be initialized</span><br></pre></td></tr></table></figure><p>总结：</p><p>数组在定义之处就已经确定了大小，在未定义的时候可以通过计算得到恰当的大小，当数组被定义出来后他的大小就无法再被改变。</p><h4 id="指针数组："><a href="#指针数组：" class="headerlink" title="指针数组："></a><strong>指针数组：</strong></h4><p>概念：一个用来存放指针的数组。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int * arr[5] ;</span><br><span class="line">int * (arr[5]) ;</span><br></pre></td></tr></table></figure><p>如何初始化以及赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line">int b = 456 ;</span><br><span class="line">int c = 789 ;</span><br><span class="line"></span><br><span class="line">// 定义并初始化</span><br><span class="line">int * arr[5] = &#123; &amp;a ,&amp;b , &amp;c &#125; ;</span><br><span class="line"></span><br><span class="line">int d = 111 ;</span><br><span class="line">int k = 555 ;</span><br><span class="line">// 给数组赋值</span><br><span class="line">arr[3] = &amp;b ;</span><br><span class="line">arr[4] = &amp;k ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何通过指针数组来访问各个指针的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line">int b = 456 ;</span><br><span class="line">int c = 789 ;</span><br><span class="line"></span><br><span class="line">// 定义并初始化</span><br><span class="line">int * arr[5] = &#123; &amp;a ,&amp;b , &amp;c &#125; ;</span><br><span class="line"></span><br><span class="line">int d = 111 ;</span><br><span class="line">int k = 555 ;</span><br><span class="line">arr[3] = &amp;b ;</span><br><span class="line">arr[4] = &amp;k ;</span><br><span class="line"></span><br><span class="line">printf( &quot;*(arr[0]):%d\n&quot; , *(arr[0]) ); // arr[0] --&gt; *(arr+0)</span><br><span class="line">printf( &quot;*(arr+1):%d\n&quot; , **(arr+1) ); // arr+1 --&gt; **（&amp;b 的地址）  -- &gt;  *(&amp;b) --&gt; b</span><br><span class="line">printf( &quot;*(2[arr]):%d\n&quot; , *(2[arr]) );</span><br><span class="line">printf( &quot;a--&gt; **arr:%d\n&quot; , **arr );</span><br></pre></td></tr></table></figure><h4 id="二维数组的加减法问题"><a href="#二维数组的加减法问题" class="headerlink" title="二维数组的加减法问题"></a><strong>二维数组的加减法问题</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int arr[3][5] =  &#123;  &#123;1,2,3,4,5&#125; , &#123;11,22,33,44,55&#125; , &#123;111,222,333,444,555&#125; &#125;;</span><br><span class="line">printf(&quot;&amp;arr:%p\n&quot; , &amp;arr);</span><br><span class="line"></span><br><span class="line">// arr 是一个数组的名字 arr[3] --&gt; 因此该数组名arr 表示的是首元素的地址</span><br><span class="line">// 首元素  &#123;1,2,3,4,5&#125;    (int  [5])</span><br><span class="line">// arr + 1 加的是一个元素的类型的大小  </span><br><span class="line">int * p = arr + 1 ; // 因此p 应该距离入口地址 5个元素*int大小 = 20 个字节</span><br><span class="line">printf(&quot;p:%p\n&quot; , p );</span><br><span class="line"></span><br><span class="line">// &amp; arr 表示整个数组的地址，因此他的类型 int [3][5]</span><br><span class="line">int * p2 = &amp;arr + 1 ; // 因此 p2 距离数组的入口地址相差 60 字节</span><br><span class="line">printf(&quot;p2:%p\n&quot; , p2 );</span><br><span class="line"></span><br><span class="line">// arr 表示首元素的地址  &#123;1,2,3,4,5&#125;</span><br><span class="line">// *arr 的是 &#123;1,2,3,4,5&#125; 的首元素的首地址</span><br><span class="line">// &#123;1,2,3,4,5&#125; 的首元素 就是 数据1 ，因此他的地址就 int 类型的</span><br><span class="line">// *arr + 1 则加一个 int 类型的大小 4字节</span><br><span class="line">int *p3 = *arr + 1 ; // p3距离 数组的入口地址相差 4 字节</span><br><span class="line">printf(&quot;p3:%p\n&quot; , p3 );</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109214352018.png" alt="image-20240109214352018"></p><p>假设有int arr [100][450]数组， 请写出访问该数组中第 1430 个元素的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[ m ] [ n ] : </span><br><span class="line">m = 1430 / 450 </span><br><span class="line">n = 1430 % 450 - 1 </span><br><span class="line"></span><br><span class="line">注意：arr[x][4]和arr[x+1][0]值相等？？？？？</span><br><span class="line">arr[3][4] - 写出 第 8 个元素：</span><br><span class="line">arr [1][3]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）指针</title>
      <link href="/2024/02/24/7.%E6%8C%87%E9%92%88/"/>
      <url>/2024/02/24/7.%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h4 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a><strong>内存地址</strong></h4><ul><li>地址的单位字节：字节是内存的容量单位，英文称为 byte，一个字节有8位，即 1byte &#x3D; 8bits</li><li>地址：系统为了便于区分每一个字节而对它们逐一进行的编号，称为内存地址，简称地址。</li></ul><p>​    <img src="data:image/png;base64,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pLR/jECgTgSCJOtEM+ZqDAH1DhVbnSnsp7HFxY07jUCQZKe3LxYfCAQC40YgSHLcCMf8IyMQgd8jQxgTjIBAkOQI4MWlC4/ATIQZZLrw+9GHOwZJ9mGXF+kzCiR/5plninvvvTf1dJ5paJOratCVV16ZimMofqEXdG5ytkghiseqAYEgyRpAjCnqRUAR31wQd1ChWu+RgiiAfM2aNakHT7VfTFmy1GJUj2jd/lQSQqyqq69evTpdF1JovXu4mGYLklxMu9nxZ0FUmthLM8y/kxAvvfTSg56MNxsx6reszaiMG6RXHeb55ZdfiptuuimRqj49xttvv1189dVXxaOPPlr8+eefqbDvWWed1XEEY/njQCBIchyoxpxDIUB61L9ZdZ833ngjNSCbmJgonnzyyVTEIg+kRhLUr5p0qIL5Y489lvK3Nb0vS5QCzZ966qk0l7/p0aOqOWnS/RTi/ffff1O7Vjnfak/GCATKCARJxnloDQLI7uqrry5+/PHHYseOHanZPGnx4YcfToHipEI/jzzySOoBvn79+qQ+I8fffvut2LJlSyqRdt1116Vm9dITNePyf9XJt23bliTGY489dsoWSQpV7XzTpk3FIYccMoVFqN+tORaNLyRIsvEtiAVkBEh2GzduLB5//PGkFiPIb7/9tti8eXNqAvbdd98Vr7zySnH66acXV111VWrmdc011ySC02xLH5yHHnooqdcPPvhgItxXX3019biR1/30008Xb775ZiLIyy+/PN2Wuj05OVm8+OKLSaqMEQhUEQiSjDPRGgRIb4jvxhtvLD744IMkNd53333pRxm0zz77rDj33HOnuiZqEoZIVQFCkt6vvzV7pVxu9k09bkiO2uEiSR5xOd6kTqo1x436kxqMVR0/rQEmFtIoAkGSjcIfNy8jwGO9e/fuJNWdf/75ScrzmkrjZZtkvgZJZknyjDPOSC+XiY5ESYX++uuvk50TSapkftlllyX7ozzve+65J1UOmi2EKHaqvwgESfZ371v35Bwyq1atKk4++eSkVvu56667ijvvvDOp4dU2smWSJEkOGh9++OEUSXoPNfycc84pTjvttGLnzp3JWRRSZOuOQ2sWFCTZmq2IhVC1cyuG1157LdkShfZQj2+99daDiGxYknzvvfdSu4cvv/wy2SqFGPF2q2Y+137esVv9QSBIsj973fonzeo2tVhmDM804qQOL1u27KD1z4ck2SYR7d9//z01j1jJs88+u1i+fHnx+uuvFzfccEOyecYIBMoIBEnGeWgVAsJ+OF8QpqH02aDUwT/++COFAK1bt64488wzZ1S3eb4RoPkPP/zw9F7So4weQ/jR0UcfXZx44omtwiMW0zwCQZLN70GsYEgEdEskbfJezzTEUFKrjzjiiCHvFJf1GYEgyT7vfsufvYmA7ibu2fJt6P3ygiR7fwS6CcCwZDbsdd1EKVZdBwJBknWgGHOMFYEmiK2Je44VxJh8aASCJIeGLi4MBAKBPiAQJNmHXe7QM/Jq58Buudz+L6e6WvORpLd///70ZGIbq722/V12zaB6lFVIsjc9enZ36LAs0FKDJBcI6LjN7Aio74gQjz/++FQjUr42rzSylM+tsngeSE3BXSmHYirFO5aHkB6ZOhdddFEKSDcQp+uqAeNeNwSvH3nkkcUJJ5ww9f7IxJl93xb7O4IkF/sOd+T53nnnnWLv3r3FbbfdVkgjVG3ca+o8KnXmZ+3atQc8jQo/yqQJPleoojzEWqo3ecUVVxTPPfdcio/ctWtXCgOqEmq+zjWK+AoqP/XUUzuCXCxz3AgESY4b4Zh/VgR+/vnnVKhCvUfEdvfdd6cqPbJkBInrRSPPeuvWrQfMRZK8/fbb03sRm5ElP9KhAPLjjjuuOOqoo9LviPeJJ55IxTOyZJknzNfphSMT5+WXX05SZYxAIEgyzkCjCJDw1H78+OOPU/FbhIYcqdeHHnpocccdd6QyZwpcVNsrIMlbbrklkeiSJUvS+26++eYkjSq1pqr5ypUrUwELEiUVXnGLiy++OJGuTJ3zzjsvVSt/4YUXUnbPDz/8kP6uLuX1118fhS8aPR3tuHmQZDv2oberUPlHTUiVxJEeYpRfTeLTtsG44IILCgUvqN7l4f3ysVUqJ1HqY/Ppp58mwmV7VLhXWTSkq3CvFg+kxEyc27dvT/P+9ddfqR6lHG6pjtRxKYykybBJ9vZoTj14kGScgUYR0HtG5R8OFu1hDdXIN2zYkF5XLo1zht1R2bTyUGeS1EjdRpDsk88++2yyaapkzgGDJDUWc/0DDzxQvPvuu0ndZu9U3fyYY45J9yKRZscQ6ZKzCOEGSTZ6PFpx8yDJVmxDfxfBHokg2R6ff/75RFTXXntt8fnnn6cq4l988UWhHewpp5xSvPXWW1PFKSBWtklmktQRkSTJnpglyelIkvebFKlJ2K+//poK+1LJhQ2pNals2ieffBIk2d+jGZJk7H07EEBWSJHkRhU+7LDDpkhSG4bff/89kWR23OSqPWWSRHRIkj1Sjcj333+/2Ldv3wEkSUq9//77k90TIbNZ6rQo7IdnnP3Sj/tRt9WYJKGGJNmOc9LkKkKSbBL9uHdC4KWXXkpqNZLUd+abb75JTpULL7wwtV/46KOPkj2xWsaMJ9rPSSedlFRrqjQi1ChMuA9VnATKKaNLohAiVc+9Tkr8559/UtsGnRmp4+Iz9+zZk2yk/u/+MQKBIMk4A40jwFFzySWXpF7anDScLortel0GDOmS06Yq1ZFCecepyH6o6itWrEhB4+Xrly5dmtRnRXrNzUHjWvUkZe2QTnNRX+q6oHZSpPvGCASCJOMMtAIB4TvaKpAEpyPEcS8SsQpmJ7FqDqa9QxS5GDfq3Zg/SLIb+7RoV1kmIuE3emBTl+voNTMbyZX/ziYq4FymDRU/RiCQEQiSjLMQCAQCgcAMCARJxvEIBAKBQCBIMs5AIBAIBALDIRCS5HC4xVWBQCDQEwSCJHuy0fGYgUAgMBwCQZLD4RZXBQKBQE8QCJLsyUbHYwYCgcBwCPwHcKocZwvVpa8AAAAASUVORK5CYII=" alt="0"></p><h4 id="基地址"><a href="#基地址" class="headerlink" title="基地址"></a><strong>基地址</strong></h4><ul><li>单字节数据：对于单字节数据而言，其地址就是其字节编号。</li><li>多字节数据：对于多字节数据而言，其地址是其所有字节中编号最小的那个，称为基地址（入口地址）。</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240109213719343.png" alt="image-20240109213719343"></p><h4 id="取址符"><a href="#取址符" class="headerlink" title="取址符"></a><strong>取址符</strong></h4><ul><li>每个变量都是一块内存，都可以通过取址符 &amp; 获取其地址</li><li>例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">printf(&quot;整型变量 a 的地址是: %p\n&quot;, &amp;a);</span><br><span class="line"></span><br><span class="line">char c = &#x27;x&#x27;;</span><br><span class="line">printf(&quot;字符变量 c 的地址是: %p\n&quot;, &amp;c);</span><br><span class="line"></span><br><span class="line">double f = 3.14;</span><br><span class="line">printf(&quot;浮点变量 f 的地址是: %p\n&quot;, &amp;f);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li><p>虽然不同的变量的尺寸是不同的，但是他们的地址的尺寸确是一样的。</p></li><li><p>不管是任何类型的数据，他们的内存地址大小都是一样的，取决于当前系统的位数（32位系统下所有的内存地址都是只有 4个字节， 64位系统所有的内存地址都是 8个字节）</p></li><li><p>不同的地址虽然形式上看起来是一样的，但由于他们代表的内存尺寸和类型都不同，因此它们在逻辑上是严格区分的。</p></li></ul></li></ul><p> <img src="/imgs/$%7Bfiilename%7D/image-20240109213748727.png" alt="image-20240109213748727"></p><h4 id="指针基础"><a href="#指针基础" class="headerlink" title="指针基础"></a><strong>指针基础</strong></h4><ul><li><p>指针的概念：</p></li><li><ul><li>地址：比如 &amp;a 是一个地址，也是一个指针，&amp;a 指向变量 a。</li><li>专门用于存储地址的变量，又称指针变量。</li></ul></li><li><p>指针的定义：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int    *p1; // 用于存储 int  型数据的地址，p1 被称为 int  型指针，或称整型指针</span><br><span class="line">char   *p2; // 用于存储 char 型数据的地址，p2 被称为 char 型指针，或称字符指针</span><br><span class="line">double *p3; // 用于存储double型数据的地址，p3 被称为 double 型指针</span><br></pre></td></tr></table></figure><ul><li>如何初始化 及赋值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 123 ;</span><br><span class="line">double d = 234523.342563456 ;</span><br><span class="line"></span><br><span class="line">int *p_a = &amp;a ; // 定义了一个指针变量 p_a 并把变量 a 的地址存入到 该变量中</span><br><span class="line">double * p_d ; // 定义了一个指针当没有赋值（野指针）</span><br><span class="line">p_d = &amp;d ;  // 给指针变量赋值</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109213823628.png" alt="image-20240109213823628"></p><p>如何通过指针来访问内存中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// * 解引用  作用是取得指针所指向内存中的值 【去地址】</span><br><span class="line">*p_a = 321 ; // 把p_a 所指向的内存的数据修改位 321 </span><br><span class="line"></span><br><span class="line">printf(&quot;a:%d\n&quot; , a);</span><br><span class="line"></span><br><span class="line">printf(&quot;*p_a:%d\n&quot; , *p_a);</span><br><span class="line">printf(&quot;*p_d:%lf\n&quot; , *p_d);</span><br></pre></td></tr></table></figure><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a><strong>野指针</strong></h4><ul><li>概念：指向一块未知区域的指针，被称为野指针。野指针是危险的。</li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240109213850806.png" alt="image-20240109213850806">   </p><p>危害：</p><ol><li>引用野指针，相当于访问了非法(未知)的内存，常常会导致段错误（segmentation fault）</li><li>引用野指针，可能会破坏系统的关键数据，导致系统崩溃等严重后果</li></ol><p>产生原因：</p><ol><li>指针定义之后，未初始化（随机值） </li><li>指针所指向的内存，被系统回收</li><li>指针越界（指针 + - 运算后）</li></ol><p>如何防止：</p><ol><li>指针定义时，及时初始化</li><li>绝不引用 已被系统回收的内存</li><li>确认所申请的内存边界，谨防越界</li></ol><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a><strong>空指针</strong></h4><p>很多情况下，我们不可避免地会遇到野指针，比如刚定义的指针无法立即为其分配一块恰当的内存，又或者指针所指向的内存被释放了等等。一般的做法就是将这些危险的野指针指向一块确定的内存，比如零地址内存。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240109213904007.png" alt="image-20240109213904007"></p><ul><li>概念：空指针即保存了零地址的指针，亦即指向零地址的指针。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1，刚定义的指针，让其指向零地址以确保安全:</span><br><span class="line">char *p1 = NULL;</span><br><span class="line">int  *p2 = NULL;</span><br><span class="line"></span><br><span class="line">// 2，被释放了内存的指针，让其指向零地址以确保安全：</span><br><span class="line">char *p3 = malloc(100); // a. 让 p3 指向一块大小为100个字节的内存</span><br><span class="line">....</span><br><span class="line">free(p3);               // b. 释放这块内存，把内存归还给系统，此时 p3 相当于指向了一块非法内存</span><br><span class="line">p3 = NULL;              // c. 让 p3 指向零地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a><strong>指针运算</strong></h4><ul><li>指针加法意味着地址向上移动若干个目标（指针的类型）</li><li>指针减法意味着地址向下移动若干个目标（指针的类型）</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int  a = 100;</span><br><span class="line">int *p = &amp;a; // 指针 p 指向整型变量 a</span><br><span class="line"></span><br><span class="line">int *k1 = p + 2; // 向上移动 2 个目标（2个int型数据）</span><br><span class="line">int *k2 = p - 3; // 向下移动 3 个目标（3个int型数据）</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109213935235.png" alt="image-20240109213935235"></p><p>指针与数组的第一个关系：</p><p>使用一个整形指针 来指向一个整形数组中的某一个元素；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int arr [5] = &#123; 1, 2, 3, 4, 5&#125; ;</span><br><span class="line">int * p = &amp;arr[2];</span><br><span class="line"></span><br><span class="line">如何通过指针p 来访问整个数组？</span><br><span class="line">p-2  得到数据1 的地址</span><br><span class="line">p-1  得到数据2 的地址</span><br><span class="line">p+1  得到数据4 的地址</span><br><span class="line"></span><br><span class="line">*p-2  先*p 得到数据 3 , 然后再 3-2 = 1  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*(p-1)  得到数据2 的值</span><br><span class="line">*(p+1)  得到数据4 的值</span><br></pre></td></tr></table></figure><h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><ul><li><p>请写出符合以下要求的定义语句。</p></li><li><ol><li>定义一个整型数 i    int  i ;</li><li>定义一个指向整型数的指针 p      int *p ;</li><li>定义一个指向整型指针的指针 k    int * *k ;</li><li>定义一个有 3 个整型数的数组 a    int a[ 3 ] ;</li><li>定义一个有 3 个整型指针的数组 b   int *  b[ 3 ]; </li><li>定义一个指向有 3 个整型元素的数组的指针 q  int (*q) [ 3 ];</li><li>定义一个指向函数的指针 r，该函数有一个整型参数并返回一个整型    int (*r) (int) ;</li></ol></li><li><p>分析下面的程序的执行结果。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;  //数组a 多大？ 4个元素， 每一个都是Int 因此整个数组 占 16字节</span><br><span class="line">    int i, *p;</span><br><span class="line">    for(i=0, p=a; i&lt;4; i++, p++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d %d\n&quot;, a[i], *p);</span><br><span class="line">        //  1 1</span><br><span class="line">        //  2 2</span><br><span class="line">        //  3 3</span><br><span class="line">        //  4 4 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阅读下面两段代码，分析程序的输出内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码片段一：</span><br><span class="line">int *p ;  // 野指针</span><br><span class="line">int a[2][2] = &#123;1, 2, 3, 0&#125;; // a[0][0] = 1  a[0][1] = 2   a[1][0] = 3  a[1][1] = 0</span><br><span class="line">p = a[0];</span><br><span class="line">printf(&quot;%d, %d&quot;, *p, *(p+1)); // 输出什么？</span><br><span class="line">输出：1 2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码片段二：</span><br><span class="line">int *p; //      a[0]     a[1]</span><br><span class="line">int a[2][2] = &#123;&#123;1, 0&#125;, &#123;2, 3&#125;&#125;;</span><br><span class="line">p= a[0];</span><br><span class="line">printf(&quot;%d, %d&quot;, *p, *(p+1)); // 输出什么？</span><br><span class="line">输出： 1 0 </span><br></pre></td></tr></table></figure><ul><li>假设有如下声明：</li></ul><p>则下列语句中那些是正确的，哪些是错误的？原因是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float a[3];</span><br><span class="line">float b[2][3];</span><br><span class="line">float c = 2.2, *p; </span><br><span class="line"></span><br><span class="line">a[3] = c;  //  a是一个数组总共有3个元素   a[3]则访问的是第4个元素 ， 因此该操作有越界的问题</span><br><span class="line">a = c;     //  a 是一个数组名， 不能直接对数组名进行赋值</span><br><span class="line">scanf(&quot;%f&quot;, &amp;a);  // a是一个数组 , &amp;a 则是获得一个数组的地址，因此该地址的类型为数组的类型 ， 类型不匹配</span><br><span class="line">printf(&quot;%f&quot;, a[3]); // a是一个数组总共有3个元素   a[3]则访问的是第4个元素 ， 因此该操作有越界的问题</span><br><span class="line">b[1][2] = a[2]; // 正确 </span><br><span class="line">b[1] = a; // b 是一个二维数组， 因此b[1]是该数组中的第二个元素 ，而该数组b 中每一个元素都是数组， 因此b[1] 也是一个数组， 不允许直接对数组进行赋值</span><br><span class="line">p = c;  // 存放地址的变量 = 浮点数  类型完全不匹配</span><br><span class="line">p = a;  // 正确   a是一个数组， 而变量名 a 在当前的语境下 代表的是该数组的首元素的首地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）数组</title>
      <link href="/2024/02/24/6.%E6%95%B0%E7%BB%84/"/>
      <url>/2024/02/24/6.%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><ul><li>逻辑：一次性定义多个相同类型的变量，并存储到一片连续的内存中</li><li>语法：</li></ul><p>数据类型  数组名字  [ 元素的数量 ] ; &#x2F;&#x2F; 定义数组  数据类型  数组名字  [ 元素的数量 ]  &#x3D; { 元素1的值 , 元素2的值, …..  ,元素N的值};&#x2F;&#x2F; 定义数组并进行初始化</p><p><strong>整形数组的定义：</strong></p><p>int  arr1 [5] ;  int  arr2 [5] &#x3D; {1 , 2 , 3 , 4 , 5}; </p><ul><li><p><strong>语法释义：</strong></p></li><li><ul><li>arr 是数组名，即这片连续内存的名称</li><li>[5] 代表这片连续内存总共分成5个相等的格子，每个格子称为数组的元素</li><li>int 代表每个元素的类型，也可以是任意基本类型，也可以是组合类型，甚至可以是数组</li></ul></li></ul><p> <img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240109213232362-17087871978833.png" alt="image-20240109213232362"></p><h4 id="如何访问数组（赋值、取值）："><a href="#如何访问数组（赋值、取值）：" class="headerlink" title="如何访问数组（赋值、取值）："></a><strong>如何访问数组（赋值、取值）：</strong></h4><ul><li>存储模式：一片连续的内存，按数据类型分割成若干相同大小的格子</li><li>元素下标：从数组开头位置的偏移量 ， 因此数组的下标就等于 偏移量</li></ul><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240109213244142.png" alt="image-20240109213244142"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组名[ 需要操作的元素下标 ] = 数据 ;   // 使用数据 给数组中某一个元素进行赋值 </span><br><span class="line">变量  = 数组名[ 需要操作的元素下标 ] ; // 使用数组中的某一个元素给 变量进行赋值</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int  arr  [5] = &#123;1,2,3,4,5&#125; ;</span><br><span class="line"></span><br><span class="line">    arr[2] = 250 ; // 把数组中的第三个数据修改位 250 </span><br><span class="line">    int tmp = arr[4] ;  // 把数组中的第五个数据取出来存放到 tmp 变量中</span><br><span class="line">    int tmp1 = arr[5] ; // 【错误】 属于越界访问， 有可能造成段错误 </span><br><span class="line"></span><br><span class="line">    // 如何遍历整个数组</span><br><span class="line">    for (int i = 0; i &lt; 5 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;arr[%d]:%d\n&quot; , i , arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;tmp:%d tmp1:%d\n&quot; , tmp , tmp1);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>初始化：在定义的时候赋值，称为初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 正常初始化</span><br><span class="line">int a[5] = &#123;100,200,300,400,500&#125;;</span><br><span class="line"></span><br><span class="line">int a[5] = &#123;100,200,300,400,500,600&#125;; // 错误，越界了 ， 编译器会直接丢弃越界部分</span><br><span class="line">int a[ ] = &#123;100,200,300&#125;; // OK，自动根据初始化列表分配数组元素个数 ， 因此该数组的元素是 3个</span><br><span class="line">int a[5] = &#123;100,200,300&#125;; // OK，只初始化数组元素的一部分， 剩余未初始化的部分会自动初始化为 0 </span><br><span class="line">int a[5] ; // 定义了一个数组，但是没有做任何的初始化，因此数组中的值是不确定的</span><br><span class="line">int a[] ; // 错误， 数组在定义的时候必须确定他的大小</span><br></pre></td></tr></table></figure><p>总结：</p><p>在定义数组时 ，数组的大小必须确定，确定数组大小的方法有两个：</p><ul><li><ul><li><ul><li>在[ ] 直接填写元素的个数</li><li>没有在 [ ] 填写大小，但是通过初始化数据的量来决定</li></ul></li></ul></li></ul><p>操作练习：</p><p>自行编写代码尝试定义一个整型数组，并对他进行初始化，完成以下操作</p><ul><li><ul><li><ul><li>输出数组中所有元素相加的值</li><li>尝试从键盘获取每一个元素的值并输出所有元素累加值</li></ul></li></ul></li></ul><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a><strong>字符数组</strong></h4><ul><li>概念：专门存放字符的数组，称为字符数组</li><li>初始化与元素引用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char s1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;&#125;;       // s1存放的是字符序列，非字符串</span><br><span class="line">char s2[6] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;\0&#x27;&#125;; // s2存放了一个【字符串】 ， 加了一个结束符\0 </span><br><span class="line"></span><br><span class="line">char s[6] = &#123;&quot;abcde&quot;&#125;; // 使用字符串直接初始化字符数组 【字符串数组】</span><br><span class="line">char s[5] = &#123;&quot;abcde&quot;&#125;; //【字符数组】 结束符没有被存入数组</span><br><span class="line">char s[6] =  &quot;abcde&quot; ; // 大括号可以省略</span><br><span class="line"></span><br><span class="line">s[0] = &#x27;A&#x27;; // 索引第一个元素，赋值为 &#x27;A&#x27;</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">char s[5] = &#123;&quot;abcde&quot;&#125;;</span><br><span class="line">char s1[] = &quot;Hello&quot; ;</span><br><span class="line"></span><br><span class="line">s[2] = &#x27;\0&#x27; ;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;s[%d]:%c\n&quot; , i , s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当使用%s进行输出数据时 ，打印函数会在遇到结束符\0的时候停止输出。</span><br><span class="line">printf(&quot;s:%s\n&quot; , s );  // 如果打印函数没有遇到结束符会一直往后访问内存，直到遇到\0或被系统终止</span><br><span class="line"></span><br><span class="line">// 格式控制符%s 所对应的参数必须是一个字符串的入口地址</span><br><span class="line">printf(&quot;s[3]:%s\n&quot; , &amp;s[3] ); </span><br><span class="line">printf(&quot;&amp;s:%p\n&quot; , &amp;s );</span><br><span class="line">printf(&quot;&amp;s1:%p\n&quot; , &amp;s1 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数组的入口地址  =  字符串常量的地址 ；</span><br><span class="line">// s = &quot;Even&quot;;  // 【错误】 不允许直接对数组名进行赋值 </span><br><span class="line">s[0] = &#x27;E&#x27;;</span><br><span class="line">s[1] = &#x27;v&#x27;;</span><br><span class="line">// .....</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a><strong>多维数组</strong></h4><ul><li>概念：若数组元素类型也是数组，则该数组称为多维数组</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3];</span><br><span class="line"></span><br><span class="line">// 代码释义：</span><br><span class="line">// 1, a[2]   是数组的定义，表示该数组拥有两个元素  【明确数组名以及元素个数】</span><br><span class="line">// 2, int [3]是元素的类型，表示该数组元素是一个具有三个元素的整型数组</span><br></pre></td></tr></table></figure><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240109213446487.png" alt="image-20240109213446487"></p><p> <img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240109213457470.png" alt="image-20240109213457470"></p><h4 id="如何对多为数组进行初始化："><a href="#如何对多为数组进行初始化：" class="headerlink" title="如何对多为数组进行初始化："></a><strong>如何对多为数组进行初始化：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型  数组名 [第一维度][第二维度] = &#123; &#123;元素1&#125; , &#123;元素2&#125; &#125; ;</span><br><span class="line">int  arr1 [2][3] = &#123; &#123; 3,4,5&#125; , &#123; 9,8,7 &#125; &#125; ; // 完全初始化</span><br><span class="line">int  arr2 [2][3] = &#123; &#123; 3,4 &#125; , &#123; 9,8 &#125; &#125; ; // 不完全初始化</span><br><span class="line">int  arr3 [2][3] = &#123; 3,4,5,9,8,7  &#125; ;</span><br></pre></td></tr></table></figure><p><strong>如何引用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int  arr1 [2][3] = &#123; &#123; 3,4,5&#125; , &#123; 9,8,7 &#125; &#125; ; // 完全初始化</span><br><span class="line">int  arr2 [2][3] = &#123; &#123; 3,4 &#125; , &#123; 9,8 &#125; &#125; ; // 不完全初始化</span><br><span class="line">int  arr3 [2][3] = &#123; 3,4,5,9,8,7  &#125; ;</span><br><span class="line"></span><br><span class="line">// [错误] &quot;Hello&quot;这是【一个参数】它只负责对arr4[0]进行赋值，因此lo\0 会被编译器丢弃</span><br><span class="line">char arr4 [2][3] = &#123;&quot;Hello&quot;&#125; ; </span><br><span class="line"></span><br><span class="line">// 这里则把&quot;Hello&quot; 拆分成了6个参数单独对数组进行赋值</span><br><span class="line">char arr5 [2][3] = &#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;, &#x27;\0&#x27;&#125; ; </span><br><span class="line"></span><br><span class="line">arr1[0][1] = 250 ; // 访问arr1 中的第0个元素 【里面】 的第1个元素</span><br><span class="line">for (int i = 0; i &lt; 2 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (int j = 0; j &lt; 3; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;arr5[%d][%d]:%c\n&quot; , i , j , arr5[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作练习：</p><p>自行编写代码尝试定义一个整型数组，并对他进行初始化，完成以下操作 [ 使用二维数组实现 ]</p><ul><li><ul><li><ul><li>输出数组中所有元素相加的值</li><li>尝试从键盘获取每一个元素的值并输出所有元素累加值</li></ul></li></ul></li></ul><h4 id="数组万能拆解法"><a href="#数组万能拆解法" class="headerlink" title="数组万能拆解法"></a><strong>数组万能拆解法</strong></h4><ul><li><p>任意的数组，不管有多复杂，其定义都由两部分组成。</p></li><li><ul><li>第1部分：说明元素的类型，可以是任意的类型（除了函数）</li><li>第2部分：说明数组名和元素个数</li></ul></li></ul><p><img src="D:/blog/hexo/source/imgs/$%7Bfiilename%7D/image-20240109213535813.png" alt="image-20240109213535813"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int   a[4];       // 第2部分：a[4]; 第1部分：int</span><br><span class="line">int   b[3][4];    // 第2部分：b[3]; 第1部分：int [4]</span><br><span class="line">int   c[2][3][4]; // 第2部分：c[2]; 第1部分：int [3][4]</span><br><span class="line">int  *d[6];       // 第2部分：d[6]; 第1部分：int *</span><br><span class="line">int (*e[7])(int, float); // 第2部分：e[7]; 第1部分：int (*)(int, float)</span><br></pre></td></tr></table></figure><ul><li><p>注解：</p></li><li><ul><li>上述示例中，a[4]、b[3]、c[2]、d[6]、e[7]本质上并无区别，它们均是数组</li><li>上述示例中，a[4]、b[3]、c[2]、d[6]、e[7]唯一的不同，是它们所存放的元素的不同</li><li>第1部分的声明语句，如果由多个单词组成，C语言规定需要将其拆散写到第2部分的两边</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）控制流</title>
      <link href="/2024/02/24/5.%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2024/02/24/5.%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h4 id="二路分支"><a href="#二路分支" class="headerlink" title="二路分支"></a><strong>二路分支</strong></h4><ul><li>逻辑：程序中某段代码需要在满足某个条件时才能运行</li><li>语法:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if语句：</span><br><span class="line">if (布尔型表达式)   // 如果  布尔型表达式 的结果位真则执行以下代码，否则不执行代码块</span><br><span class="line">&#123;</span><br><span class="line">    // 代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>形式：</p></li><li><ol><li>if 语句：表达一种 如果-则 的条件执行关系</li><li>if-else 语句：表达一种 如果-否则 的互斥分支关系</li></ol></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a = 120 ;</span><br><span class="line">    </span><br><span class="line">    if ( a &lt; 100  )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;当前a的值是大于100 的...\n&quot;);</span><br><span class="line">        return 0; // 退出当前函数，恰巧当前的函数是main 主函数 因此会导致程序直接退出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;当前a的值是小于100 的...\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109152418472.png" alt="image-20240109152418472"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if-else语句：</span><br><span class="line">if (布尔型表达式) // 如果  布尔型表达式 的结果位真则执行以下代码1， 否则则执行代码块2 </span><br><span class="line">&#123;</span><br><span class="line">    // 代码块1</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">     // 代码块2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a = 12 ;</span><br><span class="line">    </span><br><span class="line">    if ( a &gt; 100  )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;当前a的值是大于100 的...\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;当前a的值是小于或等于 100 的...\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109152447939.png" alt="image-20240109152447939"></p><ul><li><p>注意：</p></li><li><ol><li>if 语句可以单独使用，else 语句不可以，else 语句必须跟if语句配套使用  ‘else’ without a previous ‘if’</li><li>不管是 if 语句还是 else 语句，代码块都必须使用大括号 { } 括起来，否则只有首句有效 （因此从可读性上不太建议这么使用）</li></ol></li></ul><h4 id="使用二路分支if-esle-实现多路分支："><a href="#使用二路分支if-esle-实现多路分支：" class="headerlink" title="使用二路分支if-esle 实现多路分支："></a><strong>使用二路分支if-esle 实现多路分支：</strong></h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (表达式1) // 如果 表达式1 的结果位真则执行以下代码1， 然后退出 ，否则判断表达式2 </span><br><span class="line">&#123;</span><br><span class="line">    // 代码块1</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else if (表达式2 ) // 如果 表达式2 的结果位真则执行以下代码2， 否则判断表达式 3</span><br><span class="line">&#123;</span><br><span class="line">     // 代码块2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else if (表达式3 )// 如果 表达式3 的结果位真则执行以下代码3， 否则判断表达式 n</span><br><span class="line">&#123;</span><br><span class="line">     // 代码块3</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">else  // 如果以上的所有表达式都不为真 ，则执行代码块 N </span><br><span class="line">&#123;</span><br><span class="line">     // 代码块N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a><strong>多路分支</strong></h4><ul><li>逻辑：根据不同的条件执行不同的代码片段</li><li>概念： switch 会对 整型表达式 进行匹配判断 是否等于 case 中的某一个 整型常量   如果匹配则执行该case 中的代码块，否则会一直比较下去直到遇到default。 </li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">switch  ( 整型表达式 )</span><br><span class="line">&#123;</span><br><span class="line">    case 整型常量1 :</span><br><span class="line">        // 代码块1</span><br><span class="line">        break ;  // 用于跳出switch case 语句</span><br><span class="line"></span><br><span class="line">    case 整型常量2 :</span><br><span class="line">        // 代码块2</span><br><span class="line">        break ;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">    </span><br><span class="line">    case 整型常量N :</span><br><span class="line">        // 代码块N</span><br><span class="line">        break ;</span><br><span class="line">    </span><br><span class="line">    default :    </span><br><span class="line">        // 代码块M</span><br><span class="line">        break ;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int Num = 0 ;</span><br><span class="line">    int RetVal = scanf(&quot;%d&quot; , &amp;Num);</span><br><span class="line">    if (RetVal != 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf( stderr , &quot;scanf error ...\n&quot;);</span><br><span class="line">        printf(&quot;scanf error ...\n&quot;);</span><br><span class="line">        return -1 ; // 直接结束程序退出....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    switch ( Num )</span><br><span class="line">    &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;用户输入的是 1 ..\n&quot;);</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;用户输入的是 2 ..\n&quot;);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;用户输入的是 3 ..\n&quot;);</span><br><span class="line">            break ;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;用户输入的是 4 ..\n&quot;);</span><br><span class="line">            break ;</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">            printf(&quot;用户输入的并不是预想中的值 ..\n&quot;);</span><br><span class="line">            break ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>要点解析：</p></li><li><ol><li>switch(n) 语句中的 n 必须是一个整型表达式，即 switch 判断的数据必须是整型</li><li>case 语句只能使用整型常量，包括普通整型（1,2,3,4）或字符（’a’ , ‘v’ ,’n’），不包括 const 型变量。</li><li>break 语句的作用是跳出整个 swtich 结构，没有 break 程序会略过下一个case往下执行，直到遇到break 或整个switch-case语句结束</li><li>default 语句不是必须的，一般放在最后面（因此不需要 break）</li></ol></li></ul><h4 id="while与-do…while循环"><a href="#while与-do…while循环" class="headerlink" title="while与 do…while循环"></a><strong>while与 do…while循环</strong></h4><ul><li><p>逻辑：使得程序中某一段代码可以重复循环地运行</p></li><li><p>形式：</p></li><li><ul><li>while 循环：先判断，再循环</li><li>do-while 循环：先循环，再判断</li></ul></li></ul><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while( 布尔表达式1 )  // 只要表达式 1 条件是满足的则会执行代码块中的内容 </span><br><span class="line">&#123;  // 代码块 开始 </span><br><span class="line">    </span><br><span class="line">    if( 布尔表达式2 )  // 表达式2 满足的话则会执行 以下代码块 </span><br><span class="line">    &#123;</span><br><span class="line">        break; // 跳出当前while 循环体    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 代码块结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>只是用while循环语句的时候，只要while( 表达式 ) 中的表达式时成立的那么循环将一直重复地运行下去，直到遇到以下情况：</p><ul><li><ul><li>在While 循环体中执行 return ，则会直接退出当前的函数</li><li>在 While 循环体中执行 break , 则会跳出当前的循环体</li><li>在While 循环体中执行 goto语句， 则会跳到指定的代码行进行执</li></ul></li></ul><p>break 的作用，是用于跳出当前循环结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    while(2)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">          break ; // 直接跳出当前的 while 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for( ......)</span><br><span class="line">    &#123;</span><br><span class="line">        if(...)</span><br><span class="line">        &#123;</span><br><span class="line">            break ;   // 直接跳出当前的for       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    break ; // 直接跳出当前的 while 1</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do-while的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // 代码块   ， 在任何的情况下 该代码块至少会被执行一次</span><br><span class="line">    </span><br><span class="line">&#125;while( 布尔表达式 ) ;  // 当执行了一次代码块后进入 判断表达式进行判断</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240109212827022.png" alt="image-20240109212827022"></p><ul><li><p>语法点：</p></li><li><ul><li>while 循环先进行判断，条件为真后才执行循环体，因此循环体可能一遍也不执行。</li><li>do-while 循环先执行循环体，再进行判断，因此循环体至少会执行一遍。</li><li>do-while 循环中的 while 语句后面有分号；</li></ul></li></ul><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><strong>for循环</strong></h4><ul><li>逻辑：与 while 循环类似，但更加紧凑，for 循环将控制循环的变量集中在一行</li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( 表达式1  ;  表达式2  ;  表达式3  )</span><br><span class="line">&#123;</span><br><span class="line">    // 需要循环执行的代码块    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>语法点：</p></li><li><ul><li>循环头的标准语法是： for(表达式1 ; 表达式2 ; 表达式3）</li><li>表达式1一般用来初始化循环控制变量，可以是多个也可以是单个甚至没有，如果是多个的话需要使用逗号进行分割</li><li>表达式2一般用来作为循环判定条件，为真则进入循环，为假则跳出循环。 判断条件可以使用 &amp;&amp; || 逻辑运算符把多个表达式合成一个</li><li>表达式3一般用来更新循环控制变量</li><li>三个表达式均可以省略，但分号不能省略 。 则表示一个死循环类似于 while（1）</li></ul></li><li><p>示例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 循环输出一系列整数，直到100为止</span><br><span class="line">int a;</span><br><span class="line">for(a=30; a&lt;=100; a++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>在默认非使用C99 编译规则的编译器下编译程序有可能出现：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240109212919783.png" alt="image-20240109212919783"></p><p>如何解决：可以在 编译命令后面 加上选项 -std&#x3D;c99 or -std&#x3D;gnu99 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc 06\ for.c  -std=c99    </span><br><span class="line">gcc 06\ for.c  -std=gnu99</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <img src="/imgs/$%7Bfiilename%7D/image-20240109212955543.png" alt="image-20240109212955543"></p><h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a><strong>break与continue</strong></h4><ul><li><p>逻辑：</p></li><li><ul><li>break：① 跳出 switch 语句； ② 跳出当层循环体</li><li>continue：结束当次循环，进入下次循环</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">    case 1:</span><br><span class="line">        printf(&quot;one\n&quot;);</span><br><span class="line">        break;  // 跳出 switch 语句</span><br><span class="line">    case 2:</span><br><span class="line">        printf(&quot;two\n&quot;);</span><br><span class="line">        break;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    int n = scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">    if(n == 0)</span><br><span class="line">        break; // 跳出当层 while 循环体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1; i&lt;=100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(i%7 == 0)</span><br><span class="line">        continue; // 跳过所有能被7整除的数</span><br><span class="line">     </span><br><span class="line">    printf(&quot;%d\n&quot;, i);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>goto语句</strong></p><ul><li>逻辑：无条件跳转</li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goto  标签名;</span><br><span class="line"></span><br><span class="line">标签名:</span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, __LINE__); // 打印第3行 </span><br><span class="line">    </span><br><span class="line">    // 无条件跳转到label处 </span><br><span class="line">    goto label;</span><br><span class="line">    printf(&quot;%d\n&quot;, __LINE__); // 打印第7行，此处被略过</span><br><span class="line">label:  </span><br><span class="line">    printf(&quot;%d\n&quot;, __LINE__); // 打印第9行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>语法：</p></li><li><ul><li>goto语句直接跳转到本代码块中的标签处</li><li>标签指的是以冒号结尾的标识符</li></ul></li><li><p>作用：</p></li><li><ul><li>goto语句的无条件跳转不利于程序的可读性，一般在应用层不建议使用，主要出现在驱动的源代码中（底层的代码）</li><li>goto语句常被用在程序的严重错误处理中（硬件的初始化操作）</li><li>总结当程序出现了严重的错误，则可以使用goto 到程序的默认进行还原（释放空间…）并退出的操作</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）运算符</title>
      <link href="/2024/02/24/4.%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2024/02/24/4.%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h4><table><thead><tr><th>运算符</th><th>功能说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>双目加法，一目取正</td><td>a+b，+c</td></tr><tr><td>-</td><td>双目减法，一目取负</td><td>a-b,-h</td></tr><tr><td>*</td><td>乘法</td><td>a*b</td></tr><tr><td>&#x2F;</td><td>除法(在整型的运算中小数部分会直接丢失)</td><td>a&#x2F;b</td></tr><tr><td>%</td><td>取模（求余）</td><td>a%b</td></tr><tr><td>++</td><td>自加1</td><td>a++, ++b</td></tr><tr><td>- -</td><td>自减1</td><td>a–, –b</td></tr></tbody></table><ul><li><p>关注点：</p></li><li><ul><li>减号也是负号，比如 -a 是取变量 a 的相反数。</li><li>取模运算要求左右两边操作数必须是整型数据。</li><li>自加和自减运算不仅可以对整型操作，也可以对浮点数、指针操作。</li></ul></li><li><p>前缀自加自减运算：先进行自加自减，再参与表达式运算</p></li><li><p>后缀自加自减运算：先参与表达式运算，再进行自加自减</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">int b = 200;</span><br><span class="line"></span><br><span class="line">int c = ++a; // a先自加1，变成101；然后再赋值给c，因此c等于101</span><br><span class="line">int d = b++; // b先赋值给d，因此d等于200；然后b自加1，变成201</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">printf(&quot;a++:%d\n&quot; , a++ ); // 由于是后缀++ 因此会先把a的值参与运算然后再进行自加  因此输出为 3  然后再自加为 4</span><br><span class="line">printf(&quot;a:%d\n&quot; , a ); // 输出 a 为 4 </span><br><span class="line">printf(&quot;++b:%d\n&quot; , ++b ); // 由于是前缀++ 因此会先自加然后再输出</span><br><span class="line">int c = 3 ;</span><br><span class="line">int d = 4 ;</span><br><span class="line">printf(&quot;c+++d:%d\n&quot; , c+++d ); // c++ </span><br><span class="line">printf(&quot;c+++d:%d\n&quot; , c+ ++d ); //  ++d</span><br><span class="line">printf(&quot;c:%d\n&quot; , c );     </span><br><span class="line">printf(&quot;d:%d\n&quot; , d );     </span><br><span class="line">int k = c+++b;</span><br><span class="line">..</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">printf(&quot;k:%d c:%d d:%d\n&quot; , ...)</span><br><span class="line">请写出程序运行后输出的结果：</span><br><span class="line">a++:3</span><br><span class="line">a:4</span><br><span class="line">++b:6</span><br><span class="line">c+++d:7</span><br><span class="line">c+++d:9</span><br><span class="line">c:4</span><br><span class="line">d:5</span><br><span class="line">k:10 c:5 d:5</span><br></pre></td></tr></table></figure><p>注意：</p><p>gcc编译器默认是<strong>贪婪匹配规则</strong> 因此他在匹配运算符的时候，会尽可能多的从左往右把所有能组合在一起的符号组合成一个运算符</p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h4><table><thead><tr><th>运算符</th><th>功能</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td><td>a &gt; b</td><td>判断a是否大于b</td></tr><tr><td>&gt;&#x3D;</td><td>大于或等于</td><td>a &gt;&#x3D; 5</td><td>判断a是否大于或等于5</td></tr><tr><td>&lt;</td><td>小于</td><td>3 &lt; x</td><td>判断3是否小于x</td></tr><tr><td>&lt;&#x3D;</td><td>小于或等于</td><td>x &lt;&#x3D; (y+1)</td><td>判断x是否小于或等于y+1</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>(x+1) &#x3D;&#x3D; 0</td><td>判断x+1是否等于0</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>c !&#x3D; ‘\0’</td><td>判断c是否不等于’\0’</td></tr></tbody></table><ul><li><p>关注点：</p></li><li><ul><li>关系运算符用于判断运算符两边的表达式是否满足给定的大小条件。</li><li>由关系运算符组成的表达式称为关系表达式，其值为布尔型。</li><li>判断是否相等是双等号&#x3D;&#x3D;，而不是一个等号（赋值符号 &#x3D; ）。</li></ul></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h4><table><thead><tr><th>运算符</th><th>功能说明</th><th>举例</th></tr></thead><tbody><tr><td>!</td><td>逻辑反</td><td>!(x&#x3D;&#x3D;0)</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>x&gt;0 &amp;&amp; x&lt;10 （数学上0</td></tr><tr><td>||</td><td>逻辑或</td><td>y&lt;10 || y&gt; 100</td></tr></tbody></table><ul><li><p>运算规则：</p></li><li><ul><li>逻辑反：将逻辑真、假翻转，即真变假，假变真。</li><li>逻辑与：将两个或多个关系表达式串联起来，当且仅当左右两个表达式都为真时，结果为真。</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240109151816970.png" alt="image-20240109151816970"></p><ul><li><ul><li>逻辑或：将两个关系表达式并联起来，当且仅当左右两个表达式都为假时，结果为假。</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240109151828676.png" alt="image-20240109151828676"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240109151835453.png" alt="image-20240109151835453"></p><ul><li><p>特殊规则：</p></li><li><ul><li>在逻辑与运算中，如果左边表达式的值为假，那么右边表达式将不被执行。</li><li>在逻辑或运算中，如果左边表达式的值为真，那么右边表达式将不被执行。</li></ul></li></ul><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h4><p>所有的操作都是按二进制位进行操作.</p><table><thead><tr><th>运算符</th><th>名称</th><th>举例</th><th>功能说明</th></tr></thead><tbody><tr><td>~</td><td>位逻辑反</td><td>~a</td><td>将变量 a 中的每一位取反</td></tr><tr><td>&amp;</td><td>位逻辑与</td><td>a &amp; b</td><td>将变量 a 和 b 逐位进行与操作</td></tr><tr><td>|</td><td>位逻辑或</td><td>a | b</td><td>将变量 a 和 b 逐位进行或操作</td></tr><tr><td>^</td><td>位逻辑异或</td><td>a ^ b</td><td>将变量 a 和 b 逐位进行异或操作</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>a &lt;&lt; 4</td><td>将变量 a 中的每一位向左移动4位</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>x &gt;&gt; n</td><td>将变量 x 中的每一位向右移动4位</td></tr></tbody></table><ul><li><p>位运算符操作的对象是数据中的每一位</p></li><li><p>运算规则：</p></li><li><ul><li><p>位逻辑反: 把操作数的每一个位进行取反操作（0变1  1变0）</p></li><li><p>位逻辑与：把两个操作数的所对应的位进行与运算 （ &amp;  有0得0）</p></li><li><p>位逻辑或 ：把两个操作数的所对应的位进行或运算（ |  有1得1 ）</p></li><li><p>异或运算：把两个操作数的所对应的位进行异或运算 （相同为0，不同为1）</p></li><li><p>移位运算：移出去的不要，空出来的补零。移位运算都是针对无符号数的运算？？</p></li><li><ul><li>如果对负数进行右移运算那么空出来的部分补符号位 1  （对符号位进行一定的保护）</li><li>如果对负数进行左移动运算，那么符号位将会被直接覆盖 （对符号位没有任何的保护）</li></ul></li><li></li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240109151918305.png" alt="image-20240109151918305"></p><h4 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a><strong>特殊运算符</strong></h4><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h5><ul><li><ul><li>不能对常量、表达式赋值，只能对变量赋值 （赋值符号的左边（左值）不能是常量 或表达式 ）</li><li>不能对数组赋值</li><li>可以连续赋值，顺序从右到左</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a, b;</span><br><span class="line">int x[5];</span><br><span class="line"></span><br><span class="line">a = 100; // 对变量 a 赋值，正确</span><br><span class="line">(a+b) = 100; // 对表达式赋值，错误！ 【lvalue required as left operand of assignment】</span><br><span class="line">3 = 100; // 对常量 3 赋值，错误！</span><br><span class="line">x = 123; // 对数组 b 赋值，错误！</span><br><span class="line"></span><br><span class="line">// 连续赋值</span><br><span class="line">a = b = 50; // 先将 50 赋给 b，再将 b 的值赋给 a，正确</span><br><span class="line">a = b++ = 50;  // 连续赋值中也不允许出现左值为表达式或常量</span><br></pre></td></tr></table></figure><h5 id="复合赋值符"><a href="#复合赋值符" class="headerlink" title="复合赋值符"></a><strong>复合赋值符</strong></h5><ul><li><ul><li>当左右两边有相同的操作数时，采用复合赋值符不仅直观，且能提高运算效率</li><li>除了下述10个复合运算符之外，生造别的复合运算符是非法的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 加减乘除：</span><br><span class="line">a += n; // 等价于 a = a+n;</span><br><span class="line">a -= n; // 等价于 a = a-n;</span><br><span class="line">a *= n; // 等价于 a = a*n;</span><br><span class="line">a /= n; // 等价于 a = a/n;</span><br><span class="line"></span><br><span class="line">// 求余：</span><br><span class="line">a %= n; // 等价于 a = a%n;</span><br><span class="line"></span><br><span class="line">// 位运算：</span><br><span class="line">a &amp;= n; // 等价于 a = a&amp;n;</span><br><span class="line">a |= n; // 等价于 a = a|n;</span><br><span class="line">a ^= n; // 等价于 a = a^n;</span><br><span class="line">a &gt;&gt;= n; // 等价于 a = a&gt;&gt;n;</span><br><span class="line">a &lt;&lt;= n; // 等价于 a = a&lt;&lt;n;</span><br></pre></td></tr></table></figure><h5 id="条件运算符（三目运算符）"><a href="#条件运算符（三目运算符）" class="headerlink" title="条件运算符（三目运算符）"></a><strong>条件运算符（三目运算符）</strong></h5><ul><li><p>唯一需要三个操作数的运算符</p></li><li><p>语法：表达式1 ? 表达式2 : 表达式3;</p></li><li><p>释义：当表达式1为真时，取表达式2，否则取表达式3</p></li><li><ul><li>当表达式1 为真的时候取 冒号左边的表达式  否则取冒号右边的表达式</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">int b = 200;</span><br><span class="line">int m = (a&gt;b) ? a : b;  // 如果 a&gt;b 为真，则 m 取 a 的值，否则取 b 的值</span><br></pre></td></tr></table></figure><h5 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a><strong>sizeof 运算符</strong></h5><ul><li>含义：计算指定数据类型或者变量所占据内存的字节数</li><li>语法：sizeof(类型) 、sizeof(变量) ，计算变量的字节数时圆括号可以省略</li><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;, sizeof(int));</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(long double));</span><br><span class="line"></span><br><span class="line">// 【拓展】 但是用sizeof来计算数组的时候得到的是数组的实际大小（占用内存的字节数）</span><br><span class="line">int a[5];</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(a));</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof a);</span><br></pre></td></tr></table></figure><h5 id="return运算符"><a href="#return运算符" class="headerlink" title="return运算符"></a><strong>return运算符</strong></h5><ul><li><p>含义：退出某个函数（如果退出的是主函数main，那么整个程序也就退出了）</p></li><li><p>语法：必须出现在函数体内 {   }，可以带函数对应类型的数据</p></li><li><p>一般情况下 返回 0 表示正常退出 ， 返回其他值表示异常退出</p></li><li><ul><li>如果是自己写的函数，它的返回值完全可以由我们自己进行掌握可以返回任何类型的数据</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float main()</span><br><span class="line">&#123;</span><br><span class="line">    return 12.30; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级与结合性"><a href="#优先级与结合性" class="headerlink" title="优先级与结合性"></a><strong>优先级与结合性</strong></h4><ul><li>当表达式中出现不同的运算符时，根据优先级来决定谁先执行，比如先乘除，后加减</li><li>当表达式中出现多个相同优先级的运算符时，根据结合性来决定谁先运行，比如从左到右</li></ul><p>权威的结合性如何查询： <strong>man operator</strong></p><p>​    <img src="/imgs/$%7Bfiilename%7D/image-20240109152101159.png" alt="image-20240109152101159"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）数据类型的其他细节</title>
      <link href="/2024/02/24/3.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82/"/>
      <url>/2024/02/24/3.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型的其他细节"><a href="#数据类型的其他细节" class="headerlink" title="数据类型的其他细节"></a>数据类型的其他细节</h2><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><strong>类型转换</strong></h4><ul><li><p>概念：不一致但相互兼容的数据类型，在同一表达式中将会发生类型转换。</p></li><li><p>转换模式：</p></li><li><ul><li><p>隐式转换：系统按照隐式规则自动进行的转换    cel &#x3D; (5*(fah-32)) &#x2F; 9; </p></li><li><p>强制转换：用户显式自定义进行的转换     (double)a  强制把a转换成 double  </p></li><li><ul><li>语法： （目标类型）需要转换的变量名</li></ul></li></ul></li><li><p>隐式规则：从小类型向大类型转换，目的是保证不丢失表达式中数据的精度</p></li></ul><p>​    <img src="data:image/png;base64,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" alt="0"></p><h4 id="隐式转换示例代码"><a href="#隐式转换示例代码" class="headerlink" title="隐式转换示例代码"></a><strong>隐式转换示例代码</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char  a = &#x27;a&#x27;;</span><br><span class="line">int  b = 12; </span><br><span class="line">float c = 3.14; </span><br><span class="line">float x = a + b - c; // 在该表达式中将发生 [隐式转换] ，所有操作数被提升为float</span><br></pre></td></tr></table></figure><h4 id="强制转换：用户强行将某类型的数据转换为另一种类型，此过程可能丢失精度"><a href="#强制转换：用户强行将某类型的数据转换为另一种类型，此过程可能丢失精度" class="headerlink" title="强制转换：用户强行将某类型的数据转换为另一种类型，此过程可能丢失精度"></a><strong>强制转换：用户强行将某类型的数据转换为另一种类型，此过程可能丢失精度</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char  a = &#x27;a&#x27;; </span><br><span class="line">int   b = 12; </span><br><span class="line">float c = 3.14; </span><br><span class="line">float x = a + b - (int)c; // 在该表达式中a隐式自动转换为int，c被强制转为int</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>不管是隐式转换，还是强制转换，变换的都是操作数只在运算过程中的类型，是临时的，操作数本身的类型不会改变，也无法改变。</p><h4 id="数据类型的本质"><a href="#数据类型的本质" class="headerlink" title="数据类型的本质"></a><strong>数据类型的本质</strong></h4><ul><li><p>概念：各种不同的数据类型，本质上是用户与系统对某一块内存数据的解释方式的约定。</p></li><li><p>推论：</p></li><li><ul><li>类型转换，实际上是对先前定义时候的约定，做了一个临时的打破。</li><li>理论上，可以对任意的数据做任意的类型转换，但转换之后的数据解释不一定有意义。</li></ul></li></ul><p>例子：</p><p>17620828909       电话号码    银行存款    地址    坐标</p><h4 id="整型数据尺寸"><a href="#整型数据尺寸" class="headerlink" title="整型数据尺寸"></a><strong>整型数据尺寸</strong></h4><ul><li><p>概念：整型数据尺寸是指某种整型数据所占用内存空间的大小</p></li><li><p>C语言标准并未规定整型数据的具体大小，只规定了相互之间的 “ 相对大小 ” ，比如：</p></li><li><ul><li>short 不可比 int 长</li><li>long 不可比 int 短</li><li>long 型数据长度等于系统字长  （在32位系统中long &#x3D; 32位&#x3D; 4字节  、 在64为系统中 long &#x3D; 64位 &#x3D; 8字节）</li></ul></li><li><p>系统字长：CPU 一次处理的数据长度，称为字长。比如32位系统、64位系统。</p></li><li><p>典型尺寸：</p></li><li><ul><li>char 占用1个字节</li><li>short 占用2个字节</li><li>int 在16位系统中占用2个字节，在32位和64位系统中一般都占用4个字节</li><li>long 的尺寸等于系统字长</li><li>long long 在32位系统中一般占用8个字节，在64位系统中一般占用8个字节</li></ul></li></ul><p><img src="C:\Users\xuehui\AppData\Roaming\Typora\typora-user-images\image-20240109151147985.png" alt="image-20240109151147985"></p><ul><li><p>存在问题：</p></li><li><ul><li>同样的代码，放在不同的系统中，可能会由于数据尺寸发生变化而无法正常运行。 </li><li>因此，系统标准整型数据类型，是不可移植的，这个问题在底层代码中尤为突出。</li></ul></li></ul><h4 id="可移植性整型"><a href="#可移植性整型" class="headerlink" title="可移植性整型"></a><strong>可移植性整型</strong></h4><ul><li>概念：不管放到什么系统，尺寸保持不变的整型数据，称为可移植性整型</li><li>关键：typedef  用于对变量类型进行取别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int Even ; // 给int 取了一个别名 Even </span><br><span class="line">typedef int int32_t; // 将类型 int 取个别名，称为 int32_t </span><br><span class="line">typedef long int64_t;// 将类型 long 取个别名，称为 int64_t</span><br></pre></td></tr></table></figure><ul><li><p>思路：</p></li><li><ol><li>为所有的系统提供一组固定的、能反应数据尺寸的、统一的可移植性整型名称</li><li>在不同的系统中，为这些可移植性整型提供对应的 typedef 语句</li></ol><p><img src="C:\Users\xuehui\AppData\Roaming\Typora\typora-user-images\image-20240109151313742.png" alt="image-20240109151313742"></p></li><li><p>系统预定义的可移植性整型</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Convenience types.  */</span><br><span class="line">typedef unsigned char ___uchar;</span><br><span class="line">typedef unsigned short int __u_short;</span><br><span class="line">typedef unsigned int __u_int;</span><br><span class="line">typedef unsigned long int __u_long;</span><br><span class="line">/* Fixed-size types, underlying types depend on word size and compiler.  */</span><br><span class="line">typedef signed char __int8_t;</span><br><span class="line">typedef unsigned char __uint8_t;</span><br><span class="line">typedef signed short int __int16_t;</span><br><span class="line">typedef unsigned short int __uint16_t;</span><br><span class="line">typedef signed int __int32_t;</span><br><span class="line">typedef unsigned int __uint32_t;</span><br><span class="line">#if __WORDSIZE == 64</span><br><span class="line">typedef signed long int __int64_t;</span><br><span class="line">typedef unsigned long int __uint64_t;</span><br><span class="line">#else</span><br></pre></td></tr></table></figure><p>以下代码在任何的系统下运行都是的到 8 字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__int64_t i = 64 ;    </span><br><span class="line">printf(&quot;%d\n&quot; , sizeof(i));</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）基础数据结构</title>
      <link href="/2024/02/24/2.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/02/24/2.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量类型 变量名 = 初始化值；//定义变量并进行初始化工作</span><br><span class="line">变量类型   变量名  ；   // 定义变量并没有进行初始化操作 该内存中的值是未知</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160109953.png" alt="image-20240224160109953"></p><h4 id="内存大小："><a href="#内存大小：" class="headerlink" title="内存大小："></a><strong>内存大小：</strong></h4><p>二进制位 –&gt; 字节 </p><p>8个二进制位  &#x3D; 1个字节</p><p>8bit  &#x3D; 1 byte </p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h4><ul><li><p>概念：表达整数类型的数据</p></li><li><p>语法：</p></li><li><p>int  变量名 &#x3D; 初始化值 ；</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 123; // 定义了一个专门用来存储整数的变量a </span><br></pre></td></tr></table></figure><h4 id="int取值范围"><a href="#int取值范围" class="headerlink" title="int取值范围"></a><strong>int取值范围</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.int 的本意是 integer，即整数的意思</span><br><span class="line">2.int a 代表在内存中开辟一块小区域，称为 a，用来存放整数，a 一般被称为变量（实际上代表一片内存）。</span><br><span class="line">3.变量 a 所占内存大小，在不同的系统中是不一样的，64位和32位系统典型的大小是4个字节</span><br><span class="line">4.变量 a 有固定的大小，因此也有取值范围，典型的范围是：-2147483648到2147483647</span><br></pre></td></tr></table></figure><h4 id="整型修饰符"><a href="#整型修饰符" class="headerlink" title="整型修饰符"></a><strong>整型修饰符</strong></h4><ul><li><p>short：用来缩短整型变量的尺寸，减少取值范围并节省内存，称为短整型 (2byte)</p></li><li><p>long：用来增长整型变量的尺寸，增大取值范围并占用更多内存，称为长整型 (大小取决于系统的位数)</p></li><li><p>long long：用来增长整型变量的尺寸，增大取值范围并占用更多内存，称为长长整型</p></li><li><p>unsigned：用来去除整型变量的符号位，使得整型变量只能表达非负整数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">short int a; // 短整型</span><br><span class="line">long int b;  // 长整型</span><br><span class="line">long long int c; // 长长整型</span><br><span class="line"></span><br><span class="line">unsigned int e;  // 无符号整型</span><br><span class="line"></span><br><span class="line">unsigned short int f; // 无符号短整型</span><br><span class="line">unsigned long int g;  // 无符号长整型</span><br><span class="line">unsigned long long int h; // 无符号长长整型</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用整型修饰符后，关键字 int 可以被省略：</span><br><span class="line">short a; // 短整型</span><br><span class="line">long b;  // 长整型</span><br><span class="line">long long c; // 长长整型</span><br><span class="line"></span><br><span class="line">unsigned e;  // 无符号整型</span><br><span class="line"></span><br><span class="line">unsigned short f; // 无符号短整型</span><br><span class="line">unsigned long g;  // 无符号长整型</span><br><span class="line">unsigned long long h; // 无符号长长整型</span><br></pre></td></tr></table></figure><ul><li><h4 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a><strong>符号位</strong></h4></li><li><ul><li>有符号的整型数据，首位（最高位）为符号位，0表示正数，1表示负数。</li><li>无符号的整形数据，没有符号位。</li></ul></li><li><h4 id="编码形式"><a href="#编码形式" class="headerlink" title="编码形式"></a><strong>编码形式</strong></h4></li><li><ul><li>原码：正数直接使用二进制来表达，比如a&#x3D;100，在内存中是 00…001100100</li><li>补码：负数用绝对值取反加一来表达，比如a&#x3D;-3，在内存中是11…1111111101</li><li>注意负数的补码在取反加一的时候，符号位是不动的</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160254231.png" alt="image-20240224160254231"></p><ul><li><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a><strong>溢出</strong></h4></li><li><ul><li>超过数据所能表达的范围，称为溢出，就像汽车里程表，最大值和最小值是相邻的</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160300476.png" alt="image-20240224160300476"></p><ul><li><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a><strong>进制</strong></h4></li><li><ul><li>源码中可以使用八进制、十进制或十六进制，但实际数据在内存中一律是二进制</li><li>十进制（默认），比如1099</li><li>八进制，比如013   </li><li>十六进制，比如0x6FF0A</li></ul></li><li><h4 id="格式控制符"><a href="#格式控制符" class="headerlink" title="格式控制符"></a><strong>格式控制符</strong></h4></li><li><ul><li>int 整型：%d   十进制的整形</li><li>short 整型：%hd， h代表half，即一半的存储字节</li><li>long 整型：%ld</li><li>long long 整型：%lld</li><li>显示不同进制的前缀: %#o、 %#x  , %o %x</li></ul></li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h4><ul><li><p>概念：用来表达实数的数据类型 （实型）</p></li><li><p>分类：</p></li><li><ul><li>单精度浮点型（float），典型尺寸是4字节</li><li>双精度浮点型（double），典型尺寸是8字节</li><li>长双精度浮点型（long double），典型尺寸是16字节</li><li>占用内存越多，能表达的精度越高</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f1; // 单精度</span><br><span class="line">double f2; // 双精度</span><br><span class="line">long double f3; // 长双精度</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160420787.png" alt="image-20240224160420787"></p><p>浮点型数据输出格式控制符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%f   浮点输出 float  double </span><br><span class="line">%Lf  长的双精度 long double </span><br></pre></td></tr></table></figure><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a><strong>字符</strong></h4><p>字符型的数据本质上就是一个单字节的整形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch1 = &#x27;a&#x27;;  // &#x27;a&#x27;是字符常量，代表字母a  编码为 97 </span><br><span class="line">char ch2 = &#x27;\n&#x27;; // &#x27;\n&#x27;是不可见字符常量，代表回车 编码为 10 </span><br></pre></td></tr></table></figure><p>计算机中存储的都是1和0，因此各种字符都必须被映射为某个数字才能存储到计算机中，这种映射关系形成的表称为 ASCII 码表。</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160433925.png" alt="image-20240224160433925"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160440143.png" alt="image-20240224160440143"></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4><ul><li>定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 字符串的定义方式有两种：指针和数组</span><br><span class="line">char *s1 = &quot;abcd&quot;; // 使用字符指针来表示字符串</span><br><span class="line">char s2[]= &quot;abcd&quot;; // 使用字符数组来表示字符串</span><br><span class="line"></span><br><span class="line">// 注意，使用数组来定义字符串时，方括号[]里面的数字可以省略</span><br><span class="line">// 不省略也可以，但必须必字符串实际占用的内存字节数要大，比如：</span><br><span class="line">char s3[] = &quot;apple&quot;;</span><br></pre></td></tr></table></figure><ul><li><p>在内存中的存储</p></li><li><ul><li>在内存中实际上是多个连续字符的组合</li><li>任何字符串都以一个 ‘\0’ 作为结束标记，例如：“funny story” 的内存如下</li></ul></li></ul><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160501132.png" alt="image-20240224160501132"></p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224160508677.png" alt="image-20240224160508677"></p><p>如何定义及使用字符串类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char * s1 = &quot;Hello GZ2301&quot; ; // 变量 s1 中存储了 字符串常量 &quot;Hello GZ2301&quot; 的地址</span><br><span class="line"></span><br><span class="line">    printf(&quot;s1: %s \n&quot; , s1 );</span><br><span class="line"></span><br><span class="line">    // 由于s1 指向的内存地址是一个常量数据的地址</span><br><span class="line">    // *s1 = &#x27;h&#x27; ; // [错误] 会出现 Segmentation fault (core dumped) 段错误 【在访问内存时如果出现越界或非法访问的情况下会出现该错误】</span><br><span class="line">    </span><br><span class="line">    char arr[] = &quot;Hello GZ2301&quot; ; // 把字符串 &quot;Hello GZ2301&quot; 存储到 数组arr所代表的内存空间中</span><br><span class="line"></span><br><span class="line">    printf(&quot;arr:%s\n&quot; , arr );</span><br><span class="line"></span><br><span class="line">    *arr = &#x27;h&#x27; ;  // [允许] 由于arr并不是一个指针，而是一个数组，数组所占用的内存可以被修改</span><br><span class="line">    printf(&quot;arr:%s\n&quot; , arr );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>字符串与字符数据的最大区别是： </p><p>​字符是一个单独字符</p><p>​字符串则是由多个字符连续存放形成一整片内存， 并在末尾处需要添加 一个 \0 作为结束标记 （一般情况会自动添加）</p></blockquote><h4 id="布尔型数据"><a href="#布尔型数据" class="headerlink" title="布尔型数据"></a><strong>布尔型数据</strong></h4><ul><li>概念：布尔型数据只有真、假两种取值，非零为真，零为假。</li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool a = 1; // 逻辑真，此处1可以取其他任何非零数值</span><br><span class="line">bool b = 0; // 逻辑假 </span><br><span class="line">bool c = true ; // true 的值是 1 </span><br><span class="line">bool d = false ; // false 的值 0 </span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>逻辑真除了 1 之外，其他任何非零数值都表示逻辑真，等价于 1。</li><li>使用布尔型 bool 定义变量时需要包含系统头文件 stdbool.h。</li></ol><ul><li>布尔型数据常用与逻辑判断、循环控制等场合。</li></ul><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a><strong>sizeof运算符</strong></h4><p>作用： 用于计算变量 或 变量类型的大小尺寸。</p><p>语法：sizeof ( 变量 &#x2F; 变量类型 )</p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int size_a = sizeof(a);  // sizeof 可以直接对变量名字进行运算</span><br><span class="line">int size_bool = sizeof(bool); // sizeof 可以直接对变量类型进行运算</span><br><span class="line"></span><br><span class="line">printf(&quot;a: %d bool:%d \n&quot; , size_a , size_bool);</span><br><span class="line"></span><br><span class="line">printf(&quot;true:%ld false:%ld\n&quot; , sizeof(true) , sizeof(false));</span><br><span class="line"></span><br><span class="line">printf(&quot;%d,%d\n&quot; , true , false );</span><br></pre></td></tr></table></figure><h4 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a><strong>常量与变量</strong></h4><ul><li>概念：不可改变的内存数据称为常量，可以改变的内存数据称为变量</li><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;    // a是变量，而100是常量</span><br><span class="line">float f = 3.14; // f是变量，而3.14是常量</span><br><span class="line">char s[] = &quot;abcd&quot;; // s是变量，&quot;abcd&quot;是常量</span><br></pre></td></tr></table></figure><ul><li>常量的类型</li></ul><table><thead><tr><th>常量举例</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>100</td><td>整型</td><td>int</td></tr><tr><td>100L</td><td>长整型</td><td>long</td></tr><tr><td>100LL</td><td>长长整型</td><td>long long</td></tr><tr><td>100ULL</td><td>无符号长长整型</td><td>unsigned long long</td></tr><tr><td>3.14</td><td>双精度浮点型</td><td>double</td></tr><tr><td>3.14L</td><td>长双精度浮点型</td><td>long double</td></tr><tr><td>‘a’</td><td>字符型</td><td>char</td></tr><tr><td>“abcd”</td><td>字符指针（字符串）</td><td>char *</td></tr></tbody></table><h4 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a><strong>标准输入</strong></h4><ul><li>概念：键盘是系统的标准输入设备，从键盘中输入数据被称为标准输入</li><li>相关函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int scanf(const char *format, ... ); // 格式化输入函数</span><br><span class="line"></span><br><span class="line">int a;</span><br><span class="line">float f;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);   // 从键盘输入一个整型，放入指定的内存地址 &amp;a 中</span><br><span class="line">scanf(&quot;%f&quot;, &amp;f);   // 从键盘输入一个浮点数，放入指定的内存地址 &amp;f 中</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d%f&quot;, &amp;a, &amp;f); // 从键盘依次输入一个整型和一个浮点型数据，用空白符隔开</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">char s[10];</span><br><span class="line">scanf(&quot;%c&quot;, &amp;c);  // 从键盘输入一个字符，放入指定的内存地址 &amp;c 中</span><br><span class="line">scanf(&quot;%s&quot;, s );  // 从键盘输入一个单词，放入指定的数组 s 中（注意不是&amp;s）</span><br><span class="line"></span><br><span class="line">fgets(s, 10, stdin); // 从键盘输入一行字符串，放入数组 s 中</span><br></pre></td></tr></table></figure><p><strong>scanf的异常问题：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;请输入一个整型以及字符型数据：\n&quot;);</span><br><span class="line">// 在使用scanf 获取数据值必须严格按照代码中的格式进行输入</span><br><span class="line">int Ret_val = scanf( &quot;%c %d&quot; , &amp;ch , &amp;Num ); // 分别获取两个数据 并出入到对应的内存中</span><br><span class="line"></span><br><span class="line">printf(&quot;成功获得%d项输入...\n&quot; , Ret_val);</span><br><span class="line"></span><br><span class="line">printf(&quot;Num:%d ch:%c\n&quot; , Num , ch  );</span><br><span class="line"></span><br><span class="line">// 如果前面上一次使用scanf 时出现了异常，那么会有数据被scanf留在缓冲区中，</span><br><span class="line">// 因此会导致下一次使用scanf 获取数据时出现异常情况</span><br><span class="line">int Other = 0 ;</span><br><span class="line">scanf(&quot;%d&quot; , &amp;Other);</span><br><span class="line">printf(&quot;Other:%d\n&quot; , Other);</span><br></pre></td></tr></table></figure><p><strong>getchar 从标准输入中获取一个字符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int getchar(void);</span><br><span class="line">    参数分析：</span><br><span class="line">        void  --&gt; 无需参数 （使用该函数的时候无需要传递任何的参数）</span><br><span class="line">    返回值：</span><br><span class="line">        成功 返回该字符所对应的ASCII码值</span><br><span class="line">        失败 返回 EOF --&gt; -1 </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">scanf(&quot;%d %f %c&quot; , &amp;a , &amp;b , &amp;c );</span><br><span class="line">while( getchar() != &#x27;\n&#x27; ) ;  // 不断使用 getcahr 函数从标准输入中获取一个字符</span><br></pre></td></tr></table></figure><h4 id="换行符-n-的作用"><a href="#换行符-n-的作用" class="headerlink" title="换行符 \n 的作用"></a><strong>换行符 \n 的作用</strong></h4><p>概念： 提供一个换行的标记</p><p>在使用打印函数printf进行输出的时候，默认是直接把数据输出到标准输出文件中，而标准输出文件默认是具有缓冲区的，而且缓冲类型为行缓冲（当有一行数据到达缓冲区时，数据才会被刷新到终端上）。</p><p>注意：</p><pre><code> 在使用printf 打印数据的时候如果需要把数据实时显示出来则需要添加 \n 换行符，来让缓冲区及时刷新。</code></pre><p>也可是使用另外一个输出的函数 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char *format, ...);  // 默认把数据直接输出到标准输出文件中 【行缓冲】</span><br><span class="line">int fprintf(FILE *stream, const char *format, ...); // 把数据输出到指定的文件stream 中</span><br><span class="line">int dprintf(int fd, const char *format, ...); //  把数据输出到指定的文件fd 中</span><br><span class="line">int sprintf(char *str, const char *format, ...); // 把数据进行格式化处理后存入到指定内存中str</span><br><span class="line">int snprintf(char *str, size_t size, const char *format, ...);// 与上一个相同，但是有控制写入内存的字节大小 【安全版本】</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// // 如果想要输出一个%百分号， 则需要在输出语句中写两个%%</span><br><span class="line"></span><br><span class="line">printf(&quot;a%%b:%d&quot; , a%b);</span><br><span class="line"></span><br><span class="line">printf(&quot;b%%a:%d&quot; , b%a);</span><br><span class="line"></span><br><span class="line">使用以下方式输出则不需要添加\n也能实时输出  </span><br><span class="line"> 标准出错文件默认是无缓冲（任何数据到达都会立即输出）</span><br><span class="line"></span><br><span class="line">// stderr 为标准出错的文件指针</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;a%%b:%d&quot; , a%b);</span><br><span class="line"></span><br><span class="line">// 2 为标准出错的文件描述符 （文件编号）</span><br><span class="line"></span><br><span class="line">dprintf( 2 , &quot;a%%b:%d&quot; , a%b);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）C语言的基础入门（如何编辑、编译、运行）</title>
      <link href="/2024/02/24/1.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E5%A6%82%E4%BD%95%E7%BC%96%E8%BE%91%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%EF%BC%89/"/>
      <url>/2024/02/24/1.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E5%A6%82%E4%BD%95%E7%BC%96%E8%BE%91%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言的基础入门（如何编辑、编译、运行）"><a href="#C语言的基础入门（如何编辑、编译、运行）" class="headerlink" title="C语言的基础入门（如何编辑、编译、运行）"></a>C语言的基础入门（如何编辑、编译、运行）</h2><h4 id="如何编辑代码文件："><a href="#如何编辑代码文件：" class="headerlink" title="如何编辑代码文件："></a><strong>如何编辑代码文件：</strong></h4><p>可以使用任何一个你顺手的编辑器进行编写代码。</p><p>所有的C语言的程序都是从main 函数开始执行的，因此在一个项目中有且仅有一个main 函数。</p><p>C语言中函数的基本框架：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224154935375.png" alt="image-20240224154935375"></p><h4 id="如何编译程序："><a href="#如何编译程序：" class="headerlink" title="如何编译程序："></a><strong>如何编译程序：</strong></h4><p>可以直接使用gcc 编译器进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc   xxx.c    // 直接使用gcc 编译xxx.c 文件并会默认生成a.out的可执行文件</span><br></pre></td></tr></table></figure><p>可以使用gcc 编译并生成指定文件的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  xxx.c -o  TieZhu  // 使用gcc 编译xxx.c 文件并 -o 指定输出文件的名字为 TieZhu</span><br></pre></td></tr></table></figure><p>编译时出现问题不要惊慌，认证看看错误信息就没问题：</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224154952767.png" alt="image-20240224154952767"></p><h4 id="如何运行程序："><a href="#如何运行程序：" class="headerlink" title="如何运行程序："></a><strong>如何运行程序：</strong></h4><p>如果生成的文件在当前目录则直接 .&#x2F;文件名 即可</p><p><img src="/imgs/$%7Bfiilename%7D/image-20240224155009790.png" alt="image-20240224155009790"></p><h4 id="主函数参数的分析："><a href="#主函数参数的分析：" class="headerlink" title="主函数参数的分析："></a><strong>主函数参数的分析：</strong></h4><p><img src="/imgs/$%7Bfiilename%7D/image-20240224155015021.png" alt="image-20240224155015021"></p><h4 id="如何使用主函数的各项参数"><a href="#如何使用主函数的各项参数" class="headerlink" title="如何使用主函数的各项参数"></a><strong>如何使用主函数的各项参数</strong></h4><p>主函数参数的作用可以用于在运行程序时 给程序传递参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> // %d 是一个格式控制符表示需要使用的是一个整形参数 </span><br><span class="line">printf( &quot;主函数收到的参数个数为：%d \n&quot; , argc ); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// %s 用于输出字符串类型的数据 char * </span><br><span class="line">printf(&quot;第一个参数是：%s\n&quot; , argv[0]); </span><br><span class="line">printf(&quot;第二个参数是：%s\n&quot; , argv[1]); </span><br><span class="line">printf(&quot;第三个参数是：%s\n&quot; , argv[2]); </span><br><span class="line">printf(&quot;第四个参数是：%s\n&quot; , argv[3]); </span><br><span class="line">printf(&quot;第五个参数是：%s\n&quot; , argv[4]); </span><br><span class="line">                             </span><br></pre></td></tr></table></figure><h4 id="标准输出的格式控制符"><a href="#标准输出的格式控制符" class="headerlink" title="标准输出的格式控制符"></a><strong>标准输出的格式控制符</strong></h4><ul><li>概念：屏幕是系统的标准输出设备，往屏幕中输出数据被称为标准输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 格式化输出函数</span><br><span class="line">printf();   // 也称为打印函数</span><br><span class="line"></span><br><span class="line">// 根据需要输出不同格式的数据</span><br><span class="line">printf(&quot;%d\n&quot;, 100);          // 输出1个整数</span><br><span class="line">printf(&quot;%d, %d\n&quot;, 100, 200);  // 输出2个整数</span><br><span class="line"></span><br><span class="line">printf(&quot;%f\n&quot;, 3.14);      // 输出浮点数</span><br><span class="line">printf(&quot;%c\n&quot;, &#x27;x&#x27;);       // 输出字符</span><br><span class="line">printf(&quot;%s\n&quot;, &quot;abcd&quot;);    // 输出字符串</span><br></pre></td></tr></table></figure><ul><li>格式控制符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">十进制整数：%d</span><br><span class="line">八进制整数：%o</span><br><span class="line">十六进制整数：%x</span><br><span class="line">字符：%c</span><br><span class="line">字符串：%s</span><br><span class="line">单精度浮点数：%f</span><br><span class="line">双精度浮点数：%lf</span><br><span class="line">长双精度浮点数：%Lf</span><br><span class="line">地址：%p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
